/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import moment from 'moment';
import Taro, { request } from '@tarojs/taro';
export class ClientBase {
    protected getBaseUrl(defaultUrl: string, baseUrl?: string) {
        return baseUrl ? baseUrl : defaultUrl;
    }

    protected transformOptions(request: request.Param) {
        let token = Taro.getStorageSync('token');
        request.header["Authorization"] = "Bearer " + token;
        return Promise.resolve(request);
    }
}

export class AttachmentServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    upload(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/app/attachment/upload?";
        if (contentType !== undefined)
            url_ += "ContentType=" + encodeURIComponent("" + contentType) + "&"; 
        if (contentDisposition !== undefined)
            url_ += "ContentDisposition=" + encodeURIComponent("" + contentDisposition) + "&"; 
        if (headers !== undefined)
            url_ += "Headers=" + encodeURIComponent("" + headers) + "&"; 
        if (length === null)
            throw new Error("The parameter 'length' cannot be null.");
        else if (length !== undefined)
            url_ += "Length=" + encodeURIComponent("" + length) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    download(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/app/attachment/{id}/download";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class ProfilePictureServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(id: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/abp/profilepicture?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class TokenAuthServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    authenticate(model: AuthenticateModel): Promise<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class SettingPageServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getGroups(): Promise<SettingPageGroupDto[]> {
        let url_ = this.baseUrl + "/api/SettingPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpServiceProxyScriptServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getAll(type: string | null | undefined, useCache: boolean | undefined, modules: string | null | undefined, controllers: string | null | undefined, actions: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Abp/ServiceProxyScript?";
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (useCache === null)
            throw new Error("The parameter 'useCache' cannot be null.");
        else if (useCache !== undefined)
            url_ += "UseCache=" + encodeURIComponent("" + useCache) + "&"; 
        if (modules !== undefined)
            url_ += "Modules=" + encodeURIComponent("" + modules) + "&"; 
        if (controllers !== undefined)
            url_ += "Controllers=" + encodeURIComponent("" + controllers) + "&"; 
        if (actions !== undefined)
            url_ += "Actions=" + encodeURIComponent("" + actions) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpLanguagesServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    switch(culture: string | null | undefined, uiCulture: string | null | undefined, returnUrl: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Abp/Languages/Switch?";
        if (culture !== undefined)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&"; 
        if (uiCulture !== undefined)
            url_ += "uiCulture=" + encodeURIComponent("" + uiCulture) + "&"; 
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpApplicationConfigurationScriptServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(): Promise<string> {
        let url_ = this.baseUrl + "/Abp/ApplicationConfigurationScript";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpLocalizationDefinitionServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(): Promise<LanguageSwitchViewComponentModel> {
        let url_ = this.baseUrl + "/api/abp/localization-definition";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpMenuDefinitionServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(): Promise<ApplicationMenuModel> {
        let url_ = this.baseUrl + "/api/abp/menu-definition";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpTenantServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    findTenant(name: string | null): Promise<FindTenantResult> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/find-tenant/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class DataPermissionServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: NameValue): Promise<void> {
        let url_ = this.baseUrl + "/api/app/dataPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(name: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/dataPermission?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: NameValue): Promise<void> {
        let url_ = this.baseUrl + "/api/app/dataPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(name: string | null | undefined): Promise<DataPermissionDto> {
        let url_ = this.baseUrl + "/api/app/dataPermission?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getDataPermissionItems(name: string | null | undefined): Promise<DataPermissionItemDto[]> {
        let url_ = this.baseUrl + "/api/app/dataPermission/dataPermissionItems?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAllList(): Promise<DataPermissionDto[]> {
        let url_ = this.baseUrl + "/api/app/dataPermission/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getNames(): Promise<NameValue[]> {
        let url_ = this.baseUrl + "/api/app/dataPermission/names";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AccountServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    register(input: RegisterDto): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    login(login: UserLoginInfo): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    checkPassword(login: UserLoginInfo): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/checkPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpApplicationConfigurationServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(): Promise<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AbpApiDefinitionServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(): Promise<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class IdentityRoleServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getList(): Promise<ListResultDtoOfIdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: IdentityRoleCreateDto): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: IdentityRoleUpdateDto): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class IdentityUserServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(id: string): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: IdentityUserUpdateDto): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Promise<PagedResultDtoOfIdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: IdentityUserCreateDto): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getRoles(id: string): Promise<ListResultDtoOfIdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updateRoles(id: string, input: IdentityUserUpdateRolesDto): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    findByUsername(username: string | null): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-username/{userName}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    findByEmail(email: string | null): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class IdentityUserLookupServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    findById(id: string): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    findByUserName(userName: string | null): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/by-username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class ProfileServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/identity/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: UpdateProfileDto): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/identity/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    changePassword(input: ChangePasswordInput): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/my-profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PermissionsServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    get(providerName: string | null | undefined, providerKey: string | null | undefined): Promise<GetPermissionListResultDto> {
        let url_ = this.baseUrl + "/api/abp/permissions?";
        if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&"; 
        if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(providerName: string | null | undefined, providerKey: string | null | undefined, input: UpdatePermissionsDto): Promise<void> {
        let url_ = this.baseUrl + "/api/abp/permissions?";
        if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&"; 
        if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class ReportServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getPurchaseExecution(supplierName: string | null | undefined, productName: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, orderStatus: number | null | undefined): Promise<ListResultDtoOfPurchaseOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/purchaseExecution?";
        if (supplierName !== undefined)
            url_ += "SupplierName=" + encodeURIComponent("" + supplierName) + "&"; 
        if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (orderStatus !== undefined)
            url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    exportPurchaseExecution(input: GetPurchaseReportInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/exportPurchaseExecution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getPurchaseInStoreDetail(supplierName: string | null | undefined, productName: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, orderStatus: number | null | undefined): Promise<ListResultDtoOfPurchaseInOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/purchaseInStoreDetail?";
        if (supplierName !== undefined)
            url_ += "SupplierName=" + encodeURIComponent("" + supplierName) + "&"; 
        if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (orderStatus !== undefined)
            url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    exportPurchaseInStoreDetail(input: GetPurchaseReportInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/exportPurchaseInStoreDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getPurchaseOutStoreDetail(supplierName: string | null | undefined, productName: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, orderStatus: number | null | undefined): Promise<ListResultDtoOfPurchaseOutOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/purchaseOutStoreDetail?";
        if (supplierName !== undefined)
            url_ += "SupplierName=" + encodeURIComponent("" + supplierName) + "&"; 
        if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (orderStatus !== undefined)
            url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    exportPurchaseOutStoreDetail(input: GetPurchaseReportInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/exportPurchaseOutStoreDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getSalesExecution(customerName: string | null | undefined, productName: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, orderStatus: number | null | undefined): Promise<ListResultDtoOfSaleOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/salesExecution?";
        if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&"; 
        if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (orderStatus !== undefined)
            url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    exportSalesExecution(input: GetSalesReportInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/exportSalesExecution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getSalesInStoreDetail(customerName: string | null | undefined, productName: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, orderStatus: number | null | undefined): Promise<ListResultDtoOfSaleInOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/salesInStoreDetail?";
        if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&"; 
        if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (orderStatus !== undefined)
            url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    exportSalesInStoreDetail(input: GetSalesReportInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/exportSalesInStoreDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getSalesOutStoreDetail(customerName: string | null | undefined, productName: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, orderStatus: number | null | undefined): Promise<ListResultDtoOfSaleOutOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/salesOutStoreDetail?";
        if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&"; 
        if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (orderStatus !== undefined)
            url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    exportSalesOutStoreDetail(input: GetSalesReportInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/exportSalesOutStoreDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getSalesProductRanking(customerName: string | null | undefined, productName: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, orderStatus: number | null | undefined): Promise<ListResultDtoOfSalesProductRankingDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/salesProductRanking?";
        if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&"; 
        if (productName !== undefined)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (orderStatus !== undefined)
            url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    exportSalesProductRanking(input: GetSalesReportInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/report/exportSalesProductRanking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class WarehouseServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: WarehouseDto): Promise<WarehouseDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfWarehouseDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/warehouse?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/warehouse/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<WarehouseDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/warehouse/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: WarehouseDto): Promise<WarehouseDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/warehouse/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class UnitServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: UnitDto): Promise<UnitDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfUnitDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/unit?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<UnitDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: UnitDto): Promise<UnitDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getGroups(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/api/psiapp/unit/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getDefaultUnitByGroup(groupName: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/api/psiapp/unit/defaultUnitByGroup?";
        if (groupName !== undefined)
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class SupplierServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: SupplierDto): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfSupplierDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: SupplierDto): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    createContact(input: SupplierContactDto): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updateContact(input: SupplierContactDto): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    import(input: FileDto): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    export(input: DynamicQueryInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplier/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class SupplierPriceServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfSupplierPriceDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/supplierPrice?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class StoreTransferServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/storeTransfer/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/storeTransfer/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: StoreTransferDto): Promise<StoreTransferDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/storeTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfStoreTransferDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/storeTransfer?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: StoreTransferDto): Promise<StoreTransferDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/storeTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/storeTransfer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<StoreTransferDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/storeTransfer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PSISettingServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getAll(): Promise<PSISettingsEditDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/pSISetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updateAll(input: PSISettingsEditDto): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/pSISetting/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class SaleOutOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: SaleOutOrderDto): Promise<SaleOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfSaleOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: SaleOutOrderDto): Promise<SaleOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<SaleOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getItemList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<ListResultDtoOfSaleOutOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOutOrder/itemList?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class SaleOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    cancelClose(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder/{id}/cancelClose";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    close(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder/{id}/close";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: SaleOrderDto): Promise<SaleOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfSaleOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: SaleOrderDto): Promise<SaleOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<SaleOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getNotCompletedItem(customerId: string | undefined): Promise<ListResultDtoOfSaleOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleOrder/notCompletedItem?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class SaleInOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleInOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleInOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: SaleInOrderDto): Promise<SaleInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleInOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfSaleInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleInOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: SaleInOrderDto): Promise<SaleInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleInOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleInOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<SaleInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/saleInOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class SafetyStockServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: SafetyStockDto): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/safetyStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfSafetyStockDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/safetyStock?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: SafetyStockDto): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/safetyStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/safetyStock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<SafetyStockDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/safetyStock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getWarningList(skipCount: number | undefined, maxResultCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfSafetyStockWarningDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/safetyStock/warningList?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class QuotationOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/quotationOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: QuotationOrderDto): Promise<QuotationOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/quotationOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfQuotationOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/quotationOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string | undefined, input: QuotationOrderDto): Promise<QuotationOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/quotationOrder?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/quotationOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<QuotationOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/quotationOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PurchaseRequestOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    cancelClose(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder/{id}/cancelClose";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    close(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder/{id}/close";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: PurchaseRequestOrderDto): Promise<PurchaseRequestOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfPurchaseRequestOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: PurchaseRequestOrderDto): Promise<PurchaseRequestOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<PurchaseRequestOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseRequestOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PurchaseOutOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOutOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOutOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: PurchaseOutOrderDto): Promise<PurchaseOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfPurchaseOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOutOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: PurchaseOutOrderDto): Promise<PurchaseOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOutOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<PurchaseOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOutOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PurchaseOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    close(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder/{id}/close";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    cancelClose(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder/{id}/cancelClose";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: PurchaseOrderDto): Promise<PurchaseOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfPurchaseOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: PurchaseOrderDto): Promise<PurchaseOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<PurchaseOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getNotCompletedItem(supplierId: string | undefined, filter: string | null | undefined): Promise<ListResultDtoOfPurchaseOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseOrder/notCompletedItem?";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PurchaseInOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: PurchaseInOrderDto): Promise<PurchaseInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfPurchaseInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: PurchaseInOrderDto): Promise<PurchaseInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<PurchaseInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getItemList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<ListResultDtoOfPurchaseInOrderItemDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/purchaseInOrder/itemList?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class ProductServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: ProductDto): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfProductDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/product?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: ProductDto): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getWithInventory(id: string): Promise<ProductWithInventory> {
        let url_ = this.baseUrl + "/api/api/psiapp/product/{id}/withInventory";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    import(input: FileDto): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/product/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    export(input: DynamicQueryInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/product/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class ProductCategoryServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: ProductCategoryDto): Promise<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/productCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfProductCategoryDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/productCategory?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/productCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/productCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: ProductCategoryDto): Promise<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/productCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PriceServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getPurchasePrice(supplierId: string | undefined, productId: string | undefined, unitId: string | undefined, quantity: number | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/api/psiapp/price/purchasePrice?";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "supplierId=" + encodeURIComponent("" + supplierId) + "&"; 
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        if (unitId === null)
            throw new Error("The parameter 'unitId' cannot be null.");
        else if (unitId !== undefined)
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&"; 
        if (quantity === null)
            throw new Error("The parameter 'quantity' cannot be null.");
        else if (quantity !== undefined)
            url_ += "quantity=" + encodeURIComponent("" + quantity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getSalesPrice(customerId: string | undefined, productId: string | undefined, unitId: string | undefined, quantity: number | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/api/psiapp/price/salesPrice?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        if (unitId === null)
            throw new Error("The parameter 'unitId' cannot be null.");
        else if (unitId !== undefined)
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&"; 
        if (quantity === null)
            throw new Error("The parameter 'quantity' cannot be null.");
        else if (quantity !== undefined)
            url_ += "quantity=" + encodeURIComponent("" + quantity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class PriceAjustmentOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/priceAjustmentOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: PriceAjustmentOrderDto): Promise<PriceAjustmentOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/priceAjustmentOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfPriceAjustmentOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/priceAjustmentOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string | undefined, input: PriceAjustmentOrderDto): Promise<PriceAjustmentOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/priceAjustmentOrder?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/priceAjustmentOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<PriceAjustmentOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/priceAjustmentOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class OtherOutOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherOutOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherOutOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: OtherOutOrderDto): Promise<OtherOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherOutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfOtherOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherOutOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: OtherOutOrderDto): Promise<OtherOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherOutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherOutOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<OtherOutOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherOutOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class OtherInOrderServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    antiReview(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherInOrder/{id}/antiReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    audit(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherInOrder/{id}/audit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: OtherInOrderDto): Promise<OtherInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherInOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfOtherInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherInOrder?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(input: OtherInOrderDto): Promise<OtherInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherInOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherInOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<OtherInOrderDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/otherInOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class InventoryServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getAll(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfInventoryDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/inventory?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class FakerDataServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    generateData(): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/fakerData/generateData";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class CustomerServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: CustomerDto): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfCustomerDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: CustomerDto): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    createContact(input: CustomerContactDto): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updateContact(input: CustomerContactDto): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    import(input: FileDto): Promise<void> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    export(input: DynamicQueryInput): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customer/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class CustomerPriceServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfCustomerPriceDto> {
        let url_ = this.baseUrl + "/api/api/psiapp/customerPrice?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class DictionaryServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getAllList(): Promise<DictionaryItemDto[]> {
        let url_ = this.baseUrl + "/api/app/dictionary/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getCategoryList(groupName: string | null | undefined): Promise<DictionaryCategoryDto[]> {
        let url_ = this.baseUrl + "/api/app/dictionary/categoryList?";
        if (groupName !== undefined)
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getItemList(groupName: string | null | undefined, name: string | null | undefined): Promise<DictionaryItemDto[]> {
        let url_ = this.baseUrl + "/api/app/dictionary/itemList?";
        if (groupName !== undefined)
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getItem(groupName: string | null | undefined, name: string | null | undefined, value: string | null | undefined): Promise<DictionaryItemDto> {
        let url_ = this.baseUrl + "/api/app/dictionary/item?";
        if (groupName !== undefined)
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    setItem(groupName: string | null | undefined, name: string | null | undefined, value: string | null | undefined, displayValue: string | null | undefined, isDisable: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/dictionary/setItem?";
        if (groupName !== undefined)
            url_ += "groupName=" + encodeURIComponent("" + groupName) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        if (displayValue !== undefined)
            url_ += "displayValue=" + encodeURIComponent("" + displayValue) + "&"; 
        if (isDisable === null)
            throw new Error("The parameter 'isDisable' cannot be null.");
        else if (isDisable !== undefined)
            url_ += "isDisable=" + encodeURIComponent("" + isDisable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class ZeroSettingServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getAllEmailSettings(): Promise<ZeroEmailSettingDto> {
        let url_ = this.baseUrl + "/api/app/zeroSetting/emailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getAllSecuritySettings(): Promise<ZeroSecuritySettingDto> {
        let url_ = this.baseUrl + "/api/app/zeroSetting/securitySettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updteAllEmailSettings(input: ZeroEmailSettingDto): Promise<void> {
        let url_ = this.baseUrl + "/api/app/zeroSetting/updteAllEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updteAllSecuritySettings(input: ZeroSecuritySettingDto): Promise<void> {
        let url_ = this.baseUrl + "/api/app/zeroSetting/updteAllSecuritySettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AuditLogServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getList(items: ConditionItem[] | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Promise<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/app/auditLog?";
        if (items !== undefined)
            items && items.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getEntityHistorys(skipCount: number | undefined, maxResultCount: number | undefined, entityName: string | null | undefined, entityKey: string | null | undefined): Promise<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/app/auditLog/entityHistorys?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (entityName !== undefined)
            url_ += "EntityName=" + encodeURIComponent("" + entityName) + "&"; 
        if (entityKey !== undefined)
            url_ += "EntityKey=" + encodeURIComponent("" + entityKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<AuditLogListDto> {
        let url_ = this.baseUrl + "/api/app/auditLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class AnubUserServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    changePassword(currentPassword: string | null | undefined, newPassword: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/anubUser/changePassword?";
        if (currentPassword !== undefined)
            url_ += "currentPassword=" + encodeURIComponent("" + currentPassword) + "&"; 
        if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    create(input: AnubUserCreateDto): Promise<AnubUserDto> {
        let url_ = this.baseUrl + "/api/app/anubUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Promise<PagedResultDtoOfAnubUserDto> {
        let url_ = this.baseUrl + "/api/app/anubUser?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/app/anubUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "DELETE",
            header: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    get(id: string): Promise<AnubUserDto> {
        let url_ = this.baseUrl + "/api/app/anubUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    update(id: string, input: AnubUserUpdateDto): Promise<AnubUserDto> {
        let url_ = this.baseUrl + "/api/app/anubUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    findByEmail(email: string | null | undefined): Promise<AnubUserDto> {
        let url_ = this.baseUrl + "/api/app/anubUser/findByEmail?";
        if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    findByUsername(username: string | null | undefined): Promise<AnubUserDto> {
        let url_ = this.baseUrl + "/api/app/anubUser/findByUsername?";
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getRoles(id: string): Promise<ListResultDtoOfIdentityRoleDto> {
        let url_ = this.baseUrl + "/api/app/anubUser/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updateRoles(id: string, input: IdentityUserUpdateRolesDto): Promise<void> {
        let url_ = this.baseUrl + "/api/app/anubUser/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    updateProfilePicture(input: FileDto): Promise<void> {
        let url_ = this.baseUrl + "/api/app/anubUser/profilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "PUT",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class ReportTemplateServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    create(input: CreateTemplateInput): Promise<void> {
        let url_ = this.baseUrl + "/api/app/reportTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    getList(name: string | null | undefined): Promise<ListResultDtoOfReportTemplateDto> {
        let url_ = this.baseUrl + "/api/app/reportTemplate?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    download(name: string | null | undefined, templateName: string | null | undefined): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/app/reportTemplate/download?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (templateName !== undefined)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "POST",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }

    upload(input: UploadTemplateInput): Promise<void> {
        let url_ = this.baseUrl + "/api/app/reportTemplate/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_:request.Param = {
            url: url_,
            data: content_,
            method: "POST",
            header: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export class RecentAccessServiceProxy extends ClientBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = this.getBaseUrl("http://localhost:57992", baseUrl);
    }

    getList(): Promise<ListResultDtoOfApplicationMenuItem> {
        let url_ = this.baseUrl + "/api/api/recent/recentAccess";
        url_ = url_.replace(/[?&]$/, "");

        let options_:request.Param = {
            url: url_,
            method: "GET",
            header: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return Taro.request({...transformedOptions_});
        }).then((_response: request.Promised) => {
            return _response.data;
        });
    }
}

export abstract class IHeaderDictionary implements IIHeaderDictionary {
    item!: string[];
    contentLength!: number | undefined;

    constructor(data?: IIHeaderDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["item"])) {
                this.item = [] as any;
                for (let item of data["item"])
                    this.item!.push(item);
            }
            this.contentLength = data["contentLength"];
        }
    }

    static fromJS(data: any): IHeaderDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IHeaderDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item)) {
            data["item"] = [];
            for (let item of this.item)
                data["item"].push(item);
        }
        data["contentLength"] = this.contentLength;
        return data; 
    }
}

export interface IIHeaderDictionary {
    item: string[];
    contentLength: number | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    userId!: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient!: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class SettingPageGroupDto implements ISettingPageGroupDto {
    id!: string | undefined;

    constructor(data?: ISettingPageGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SettingPageGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingPageGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ISettingPageGroupDto {
    id: string | undefined;
}

export class LanguageSwitchViewComponentModel implements ILanguageSwitchViewComponentModel {
    currentLanguage!: LanguageInfo | undefined;
    otherLanguages!: LanguageInfo[] | undefined;

    constructor(data?: ILanguageSwitchViewComponentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentLanguage = data["currentLanguage"] ? LanguageInfo.fromJS(data["currentLanguage"]) : <any>undefined;
            if (Array.isArray(data["otherLanguages"])) {
                this.otherLanguages = [] as any;
                for (let item of data["otherLanguages"])
                    this.otherLanguages!.push(LanguageInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LanguageSwitchViewComponentModel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageSwitchViewComponentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentLanguage"] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
        if (Array.isArray(this.otherLanguages)) {
            data["otherLanguages"] = [];
            for (let item of this.otherLanguages)
                data["otherLanguages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILanguageSwitchViewComponentModel {
    currentLanguage: LanguageInfo | undefined;
    otherLanguages: LanguageInfo[] | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    cultureName!: string | undefined;
    uiCultureName!: string | undefined;
    displayName!: string | undefined;
    flagIcon!: string | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cultureName = data["cultureName"];
            this.uiCultureName = data["uiCultureName"];
            this.displayName = data["displayName"];
            this.flagIcon = data["flagIcon"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        return data; 
    }
}

export interface ILanguageInfo {
    cultureName: string | undefined;
    uiCultureName: string | undefined;
    displayName: string | undefined;
    flagIcon: string | undefined;
}

export class ApplicationMenuModel implements IApplicationMenuModel {
    items!: ApplicationMenuItem[] | undefined;

    constructor(data?: IApplicationMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationMenuModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationMenuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplicationMenuModel {
    items: ApplicationMenuItem[] | undefined;
}

export class ApplicationMenuItem implements IApplicationMenuItem {
    name!: string | undefined;
    displayName!: string | undefined;
    order!: number;
    url!: string | undefined;
    icon!: string | undefined;
    isLeaf!: boolean;
    target!: string | undefined;
    isDisabled!: boolean;
    items!: ApplicationMenuItem[] | undefined;
    customData!: any | undefined;
    elementId!: string | undefined;
    cssClass!: string | undefined;

    constructor(data?: IApplicationMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.order = data["order"];
            this.url = data["url"];
            this.icon = data["icon"];
            this.isLeaf = data["isLeaf"];
            this.target = data["target"];
            this.isDisabled = data["isDisabled"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationMenuItem.fromJS(item));
            }
            this.customData = data["customData"];
            this.elementId = data["elementId"];
            this.cssClass = data["cssClass"];
        }
    }

    static fromJS(data: any): ApplicationMenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationMenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["order"] = this.order;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["isLeaf"] = this.isLeaf;
        data["target"] = this.target;
        data["isDisabled"] = this.isDisabled;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["customData"] = this.customData;
        data["elementId"] = this.elementId;
        data["cssClass"] = this.cssClass;
        return data; 
    }
}

export interface IApplicationMenuItem {
    name: string | undefined;
    displayName: string | undefined;
    order: number;
    url: string | undefined;
    icon: string | undefined;
    isLeaf: boolean;
    target: string | undefined;
    isDisabled: boolean;
    items: ApplicationMenuItem[] | undefined;
    customData: any | undefined;
    elementId: string | undefined;
    cssClass: string | undefined;
}

export class FindTenantResult implements IFindTenantResult {
    success!: boolean;
    tenantId!: string | undefined;

    constructor(data?: IFindTenantResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): FindTenantResult {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IFindTenantResult {
    success: boolean;
    tenantId: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class NameValue extends NameValueOfString implements INameValue {

    constructor(data?: INameValue) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface INameValue extends INameValueOfString {
}

export class DataPermissionItemDto implements IDataPermissionItemDto {
    navigationListProperty!: string | undefined;
    name!: string | undefined;
    value!: string | undefined;
    text!: string | undefined;
    type!: string | undefined;

    constructor(data?: IDataPermissionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.navigationListProperty = data["navigationListProperty"];
            this.name = data["name"];
            this.value = data["value"];
            this.text = data["text"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): DataPermissionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataPermissionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["navigationListProperty"] = this.navigationListProperty;
        data["name"] = this.name;
        data["value"] = this.value;
        data["text"] = this.text;
        data["type"] = this.type;
        return data; 
    }
}

export interface IDataPermissionItemDto {
    navigationListProperty: string | undefined;
    name: string | undefined;
    value: string | undefined;
    text: string | undefined;
    type: string | undefined;
}

export class DataPermissionDto implements IDataPermissionDto {
    name!: string | undefined;
    displayName!: string | undefined;
    value!: string | undefined;

    constructor(data?: IDataPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): DataPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        return data; 
    }
}

export interface IDataPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    value: string | undefined;
}

export abstract class EntityDto implements IEntityDto {

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IEntityDto {
}

export abstract class EntityDtoOfGuid extends EntityDto implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityDtoOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IEntityDtoOfGuid extends IEntityDto {
    id: string;
}

export abstract class CreationAuditedEntityDtoOfGuid extends EntityDtoOfGuid implements ICreationAuditedEntityDtoOfGuid {
    creationTime!: moment.Moment;
    creatorId!: string | undefined;

    constructor(data?: ICreationAuditedEntityDtoOfGuid) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorId = data["creatorId"];
        }
    }

    static fromJS(data: any): CreationAuditedEntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CreationAuditedEntityDtoOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreationAuditedEntityDtoOfGuid extends IEntityDtoOfGuid {
    creationTime: moment.Moment;
    creatorId: string | undefined;
}

export abstract class AuditedEntityDtoOfGuid extends CreationAuditedEntityDtoOfGuid implements IAuditedEntityDtoOfGuid {
    lastModificationTime!: moment.Moment | undefined;
    lastModifierId!: string | undefined;

    constructor(data?: IAuditedEntityDtoOfGuid) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = data["lastModifierId"];
        }
    }

    static fromJS(data: any): AuditedEntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditedEntityDtoOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        super.toJSON(data);
        return data; 
    }
}

export interface IAuditedEntityDtoOfGuid extends ICreationAuditedEntityDtoOfGuid {
    lastModificationTime: moment.Moment | undefined;
    lastModifierId: string | undefined;
}

export abstract class FullAuditedEntityDtoOfGuid extends AuditedEntityDtoOfGuid implements IFullAuditedEntityDtoOfGuid {
    isDeleted!: boolean;
    deleterId!: string | undefined;
    deletionTime!: moment.Moment | undefined;

    constructor(data?: IFullAuditedEntityDtoOfGuid) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.isDeleted = data["isDeleted"];
            this.deleterId = data["deleterId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FullAuditedEntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FullAuditedEntityDtoOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IFullAuditedEntityDtoOfGuid extends IAuditedEntityDtoOfGuid {
    isDeleted: boolean;
    deleterId: string | undefined;
    deletionTime: moment.Moment | undefined;
}

export class IdentityUserDto extends FullAuditedEntityDtoOfGuid implements IIdentityUserDto {
    tenantId!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string | undefined;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnabled!: boolean;
    lockoutEnd!: moment.Moment | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityUserDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.tenantId = data["tenantId"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.emailConfirmed = data["emailConfirmed"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneNumberConfirmed = data["phoneNumberConfirmed"];
            this.twoFactorEnabled = data["twoFactorEnabled"];
            this.lockoutEnabled = data["lockoutEnabled"];
            this.lockoutEnd = data["lockoutEnd"] ? moment(data["lockoutEnd"].toString()) : <any>undefined;
            this.concurrencyStamp = data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityUserDto extends IFullAuditedEntityDtoOfGuid {
    tenantId: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    email: string | undefined;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    userName!: string;
    emailAddress!: string;
    password!: string;
    appName!: string;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.appName = data["appName"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["appName"] = this.appName;
        return data; 
    }
}

export interface IRegisterDto {
    userName: string;
    emailAddress: string;
    password: string;
    appName: string;
}

export class AbpLoginResult implements IAbpLoginResult {
    result!: LoginResultType;
    description!: string | undefined;

    constructor(data?: IAbpLoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): AbpLoginResult {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLoginResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["description"] = this.description;
        return data; 
    }
}

export interface IAbpLoginResult {
    result: LoginResultType;
    description: string | undefined;
}

export enum LoginResultType {
    Success = 1,
    InvalidUserNameOrPassword = 2,
    NotAllowed = 3,
    LockedOut = 4,
    RequiresTwoFactor = 5,
}

export class UserLoginInfo implements IUserLoginInfo {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberMe!: boolean;
    tenanId!: string | undefined;

    constructor(data?: IUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberMe = data["rememberMe"];
            this.tenanId = data["tenanId"];
        }
    }

    static fromJS(data: any): UserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        data["tenanId"] = this.tenanId;
        return data; 
    }
}

export interface IUserLoginInfo {
    userNameOrEmailAddress: string;
    password: string;
    rememberMe: boolean;
    tenanId: string | undefined;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
    localization!: ApplicationLocalizationConfigurationDto | undefined;
    auth!: ApplicationAuthConfigurationDto | undefined;
    setting!: ApplicationSettingConfigurationDto | undefined;
    currentUser!: CurrentUserDto | undefined;
    features!: ApplicationFeatureConfigurationDto | undefined;

    constructor(data?: IApplicationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.localization = data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(data["localization"]) : <any>undefined;
            this.auth = data["auth"] ? ApplicationAuthConfigurationDto.fromJS(data["auth"]) : <any>undefined;
            this.setting = data["setting"] ? ApplicationSettingConfigurationDto.fromJS(data["setting"]) : <any>undefined;
            this.currentUser = data["currentUser"] ? CurrentUserDto.fromJS(data["currentUser"]) : <any>undefined;
            this.features = data["features"] ? ApplicationFeatureConfigurationDto.fromJS(data["features"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApplicationConfigurationDto {
    localization: ApplicationLocalizationConfigurationDto | undefined;
    auth: ApplicationAuthConfigurationDto | undefined;
    setting: ApplicationSettingConfigurationDto | undefined;
    currentUser: CurrentUserDto | undefined;
    features: ApplicationFeatureConfigurationDto | undefined;
}

export class ApplicationLocalizationConfigurationDto implements IApplicationLocalizationConfigurationDto {
    values!: { [key: string]: { [key: string]: string; }; } | undefined;
    languages!: LanguageInfo[] | undefined;

    constructor(data?: IApplicationLocalizationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values![key] = data["values"][key] !== undefined ? data["values"][key] : {};
                }
            }
            if (Array.isArray(data["languages"])) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplicationLocalizationConfigurationDto {
    values: { [key: string]: { [key: string]: string; }; } | undefined;
    languages: LanguageInfo[] | undefined;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
    policies!: { [key: string]: boolean; } | undefined;
    grantedPolicies!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationAuthConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["policies"]) {
                this.policies = {} as any;
                for (let key in data["policies"]) {
                    if (data["policies"].hasOwnProperty(key))
                        this.policies![key] = data["policies"][key];
                }
            }
            if (data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in data["grantedPolicies"]) {
                    if (data["grantedPolicies"].hasOwnProperty(key))
                        this.grantedPolicies![key] = data["grantedPolicies"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationAuthConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAuthConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.policies) {
            data["policies"] = {};
            for (let key in this.policies) {
                if (this.policies.hasOwnProperty(key))
                    data["policies"][key] = this.policies[key];
            }
        }
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    data["grantedPolicies"][key] = this.grantedPolicies[key];
            }
        }
        return data; 
    }
}

export interface IApplicationAuthConfigurationDto {
    policies: { [key: string]: boolean; } | undefined;
    grantedPolicies: { [key: string]: boolean; } | undefined;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationSettingConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values![key] = data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationSettingConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }
}

export interface IApplicationSettingConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class CurrentUserDto implements ICurrentUserDto {
    isAuthenticated!: boolean;
    id!: string | undefined;
    tenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: ICurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isAuthenticated = data["isAuthenticated"];
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICurrentUserDto {
    isAuthenticated: boolean;
    id: string | undefined;
    tenantId: string | undefined;
    userName: string | undefined;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values![key] = data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }
}

export interface IApplicationFeatureConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
    modules!: { [key: string]: ModuleApiDescriptionModel; } | undefined;

    constructor(data?: IApplicationApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["modules"]) {
                this.modules = {} as any;
                for (let key in data["modules"]) {
                    if (data["modules"].hasOwnProperty(key))
                        this.modules![key] = data["modules"][key] ? ModuleApiDescriptionModel.fromJS(data["modules"][key]) : new ModuleApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    data["modules"][key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }
}

export interface IApplicationApiDescriptionModel {
    modules: { [key: string]: ModuleApiDescriptionModel; } | undefined;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
    rootPath!: string | undefined;
    controllers!: { [key: string]: ControllerApiDescriptionModel; } | undefined;

    constructor(data?: IModuleApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rootPath = data["rootPath"];
            if (data["controllers"]) {
                this.controllers = {} as any;
                for (let key in data["controllers"]) {
                    if (data["controllers"].hasOwnProperty(key))
                        this.controllers![key] = data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(data["controllers"][key]) : new ControllerApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ModuleApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    data["controllers"][key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }
}

export interface IModuleApiDescriptionModel {
    rootPath: string | undefined;
    controllers: { [key: string]: ControllerApiDescriptionModel; } | undefined;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
    controllerName!: string | undefined;
    typeAsString!: string | undefined;
    interfaces!: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions!: { [key: string]: ActionApiDescriptionModel; } | undefined;

    constructor(data?: IControllerApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.controllerName = data["controllerName"];
            this.typeAsString = data["typeAsString"];
            if (Array.isArray(data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
            }
            if (data["actions"]) {
                this.actions = {} as any;
                for (let key in data["actions"]) {
                    if (data["actions"].hasOwnProperty(key))
                        this.actions![key] = data["actions"][key] ? ActionApiDescriptionModel.fromJS(data["actions"][key]) : new ActionApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ControllerApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName;
        data["typeAsString"] = this.typeAsString;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    data["actions"][key] = this.actions[key] ? this.actions[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }
}

export interface IControllerApiDescriptionModel {
    controllerName: string | undefined;
    typeAsString: string | undefined;
    interfaces: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions: { [key: string]: ActionApiDescriptionModel; } | undefined;
}

export class ControllerInterfaceApiDescriptionModel implements IControllerInterfaceApiDescriptionModel {
    typeAsString!: string | undefined;

    constructor(data?: IControllerInterfaceApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeAsString = data["typeAsString"];
        }
    }

    static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerInterfaceApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeAsString"] = this.typeAsString;
        return data; 
    }
}

export interface IControllerInterfaceApiDescriptionModel {
    typeAsString: string | undefined;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
    uniqueName!: string | undefined;
    name!: string | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    supportedVersions!: string[] | undefined;
    parametersOnMethod!: MethodParameterApiDescriptionModel[] | undefined;
    parameters!: ParameterApiDescriptionModel[] | undefined;
    returnValue!: ReturnValueApiDescriptionModel | undefined;

    constructor(data?: IActionApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uniqueName = data["uniqueName"];
            this.name = data["name"];
            this.httpMethod = data["httpMethod"];
            this.url = data["url"];
            if (Array.isArray(data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            if (Array.isArray(data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            if (Array.isArray(data["parameters"])) {
                this.parameters = [] as any;
                for (let item of data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(data["returnValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName;
        data["name"] = this.name;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionApiDescriptionModel {
    uniqueName: string | undefined;
    name: string | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    supportedVersions: string[] | undefined;
    parametersOnMethod: MethodParameterApiDescriptionModel[] | undefined;
    parameters: ParameterApiDescriptionModel[] | undefined;
    returnValue: ReturnValueApiDescriptionModel | undefined;
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
    name!: string | undefined;
    typeAsString!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;

    constructor(data?: IMethodParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.typeAsString = data["typeAsString"];
            this.isOptional = data["isOptional"];
            this.defaultValue = data["defaultValue"];
        }
    }

    static fromJS(data: any): MethodParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new MethodParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeAsString"] = this.typeAsString;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        return data; 
    }
}

export interface IMethodParameterApiDescriptionModel {
    name: string | undefined;
    typeAsString: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
    nameOnMethod!: string | undefined;
    name!: string | undefined;
    typeAsString!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;
    constraintTypes!: string[] | undefined;
    bindingSourceId!: string | undefined;

    constructor(data?: IParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nameOnMethod = data["nameOnMethod"];
            this.name = data["name"];
            this.typeAsString = data["typeAsString"];
            this.isOptional = data["isOptional"];
            this.defaultValue = data["defaultValue"];
            if (Array.isArray(data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            this.bindingSourceId = data["bindingSourceId"];
        }
    }

    static fromJS(data: any): ParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod;
        data["name"] = this.name;
        data["typeAsString"] = this.typeAsString;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId;
        return data; 
    }
}

export interface IParameterApiDescriptionModel {
    nameOnMethod: string | undefined;
    name: string | undefined;
    typeAsString: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
    constraintTypes: string[] | undefined;
    bindingSourceId: string | undefined;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
    typeAsString!: string | undefined;

    constructor(data?: IReturnValueApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeAsString = data["typeAsString"];
        }
    }

    static fromJS(data: any): ReturnValueApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnValueApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeAsString"] = this.typeAsString;
        return data; 
    }
}

export interface IReturnValueApiDescriptionModel {
    typeAsString: string | undefined;
}

export class ListResultDtoOfIdentityRoleDto implements IListResultDtoOfIdentityRoleDto {
    items!: IdentityRoleDto[] | undefined;

    constructor(data?: IListResultDtoOfIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfIdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfIdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfIdentityRoleDto {
    items: IdentityRoleDto[] | undefined;
}

export class IdentityRoleDto extends EntityDtoOfGuid implements IIdentityRoleDto {
    name!: string | undefined;
    isDefault!: boolean;
    isStatic!: boolean;
    isPublic!: boolean;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityRoleDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.isDefault = data["isDefault"];
            this.isStatic = data["isStatic"];
            this.isPublic = data["isPublic"];
            this.concurrencyStamp = data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityRoleDto extends IEntityDtoOfGuid {
    name: string | undefined;
    isDefault: boolean;
    isStatic: boolean;
    isPublic: boolean;
    concurrencyStamp: string | undefined;
}

export class IdentityRoleCreateOrUpdateDtoBase implements IIdentityRoleCreateOrUpdateDtoBase {
    name!: string;
    isDefault!: boolean;
    isPublic!: boolean;

    constructor(data?: IIdentityRoleCreateOrUpdateDtoBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isDefault = data["isDefault"];
            this.isPublic = data["isPublic"];
        }
    }

    static fromJS(data: any): IdentityRoleCreateOrUpdateDtoBase {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleCreateOrUpdateDtoBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        return data; 
    }
}

export interface IIdentityRoleCreateOrUpdateDtoBase {
    name: string;
    isDefault: boolean;
    isPublic: boolean;
}

export class IdentityRoleCreateDto extends IdentityRoleCreateOrUpdateDtoBase implements IIdentityRoleCreateDto {

    constructor(data?: IIdentityRoleCreateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): IdentityRoleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityRoleCreateDto extends IIdentityRoleCreateOrUpdateDtoBase {
}

export class IdentityRoleUpdateDto extends IdentityRoleCreateOrUpdateDtoBase implements IIdentityRoleUpdateDto {
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityRoleUpdateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.concurrencyStamp = data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["concurrencyStamp"] = this.concurrencyStamp;
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityRoleUpdateDto extends IIdentityRoleCreateOrUpdateDtoBase {
    concurrencyStamp: string | undefined;
}

export class ListResultDtoOfIdentityUserDto implements IListResultDtoOfIdentityUserDto {
    items!: IdentityUserDto[] | undefined;

    constructor(data?: IListResultDtoOfIdentityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IdentityUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfIdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfIdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfIdentityUserDto {
    items: IdentityUserDto[] | undefined;
}

export class PagedResultDtoOfIdentityUserDto extends ListResultDtoOfIdentityUserDto implements IPagedResultDtoOfIdentityUserDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfIdentityUserDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfIdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfIdentityUserDto extends IListResultDtoOfIdentityUserDto {
    totalCount: number;
}

export abstract class IdentityUserCreateOrUpdateDtoBase implements IIdentityUserCreateOrUpdateDtoBase {
    userName!: string;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string;
    phoneNumber!: string | undefined;
    twoFactorEnabled!: boolean;
    lockoutEnabled!: boolean;
    roleNames!: string[] | undefined;

    constructor(data?: IIdentityUserCreateOrUpdateDtoBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.phoneNumber = data["phoneNumber"];
            this.twoFactorEnabled = data["twoFactorEnabled"];
            this.lockoutEnabled = data["lockoutEnabled"];
            if (Array.isArray(data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of data["roleNames"])
                    this.roleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityUserCreateOrUpdateDtoBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IdentityUserCreateOrUpdateDtoBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data; 
    }
}

export interface IIdentityUserCreateOrUpdateDtoBase {
    userName: string;
    name: string | undefined;
    surname: string | undefined;
    email: string;
    phoneNumber: string | undefined;
    twoFactorEnabled: boolean;
    lockoutEnabled: boolean;
    roleNames: string[] | undefined;
}

export class IdentityUserCreateDto extends IdentityUserCreateOrUpdateDtoBase implements IIdentityUserCreateDto {
    password!: string;

    constructor(data?: IIdentityUserCreateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.password = data["password"];
        }
    }

    static fromJS(data: any): IdentityUserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityUserCreateDto extends IIdentityUserCreateOrUpdateDtoBase {
    password: string;
}

export class IdentityUserUpdateDto extends IdentityUserCreateOrUpdateDtoBase implements IIdentityUserUpdateDto {
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityUserUpdateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.concurrencyStamp = data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityUserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["concurrencyStamp"] = this.concurrencyStamp;
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityUserUpdateDto extends IIdentityUserCreateOrUpdateDtoBase {
    concurrencyStamp: string | undefined;
}

export class IdentityUserUpdateRolesDto implements IIdentityUserUpdateRolesDto {
    roleNames!: string[];

    constructor(data?: IIdentityUserUpdateRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of data["roleNames"])
                    this.roleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityUserUpdateRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data; 
    }
}

export interface IIdentityUserUpdateRolesDto {
    roleNames: string[];
}

export class UserData implements IUserData {
    id!: string;
    tenantId!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string | undefined;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.emailConfirmed = data["emailConfirmed"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneNumberConfirmed = data["phoneNumberConfirmed"];
        }
    }

    static fromJS(data: any): UserData {
        data = typeof data === 'object' ? data : {};
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        return data; 
    }
}

export interface IUserData {
    id: string;
    tenantId: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    email: string | undefined;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
}

export class ProfileDto implements IProfileDto {
    userName!: string | undefined;
    email!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.email = data["email"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): ProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IProfileDto {
    userName: string | undefined;
    email: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    phoneNumber: string | undefined;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    userName!: string | undefined;
    email!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.email = data["email"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUpdateProfileDto {
    userName: string | undefined;
    email: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class GetPermissionListResultDto implements IGetPermissionListResultDto {
    entityDisplayName!: string | undefined;
    groups!: PermissionGroupDto[] | undefined;

    constructor(data?: IGetPermissionListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityDisplayName = data["entityDisplayName"];
            if (Array.isArray(data["groups"])) {
                this.groups = [] as any;
                for (let item of data["groups"])
                    this.groups!.push(PermissionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPermissionListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDisplayName"] = this.entityDisplayName;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPermissionListResultDto {
    entityDisplayName: string | undefined;
    groups: PermissionGroupDto[] | undefined;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    name!: string | undefined;
    displayName!: string | undefined;
    permissions!: PermissionGrantInfoDto[] | undefined;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            if (Array.isArray(data["permissions"])) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(PermissionGrantInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPermissionGroupDto {
    name: string | undefined;
    displayName: string | undefined;
    permissions: PermissionGrantInfoDto[] | undefined;
}

export class PermissionGrantInfoDto implements IPermissionGrantInfoDto {
    name!: string | undefined;
    displayName!: string | undefined;
    parentName!: string | undefined;
    isGranted!: boolean;
    allowedProviders!: string[] | undefined;
    grantedProviders!: ProviderInfoDto[] | undefined;

    constructor(data?: IPermissionGrantInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.parentName = data["parentName"];
            this.isGranted = data["isGranted"];
            if (Array.isArray(data["allowedProviders"])) {
                this.allowedProviders = [] as any;
                for (let item of data["allowedProviders"])
                    this.allowedProviders!.push(item);
            }
            if (Array.isArray(data["grantedProviders"])) {
                this.grantedProviders = [] as any;
                for (let item of data["grantedProviders"])
                    this.grantedProviders!.push(ProviderInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGrantInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["parentName"] = this.parentName;
        data["isGranted"] = this.isGranted;
        if (Array.isArray(this.allowedProviders)) {
            data["allowedProviders"] = [];
            for (let item of this.allowedProviders)
                data["allowedProviders"].push(item);
        }
        if (Array.isArray(this.grantedProviders)) {
            data["grantedProviders"] = [];
            for (let item of this.grantedProviders)
                data["grantedProviders"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPermissionGrantInfoDto {
    name: string | undefined;
    displayName: string | undefined;
    parentName: string | undefined;
    isGranted: boolean;
    allowedProviders: string[] | undefined;
    grantedProviders: ProviderInfoDto[] | undefined;
}

export class ProviderInfoDto implements IProviderInfoDto {
    providerName!: string | undefined;
    providerKey!: string | undefined;

    constructor(data?: IProviderInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.providerName = data["providerName"];
            this.providerKey = data["providerKey"];
        }
    }

    static fromJS(data: any): ProviderInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        return data; 
    }
}

export interface IProviderInfoDto {
    providerName: string | undefined;
    providerKey: string | undefined;
}

export class UpdatePermissionsDto implements IUpdatePermissionsDto {
    permissions!: UpdatePermissionDto[] | undefined;

    constructor(data?: IUpdatePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["permissions"])) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(UpdatePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdatePermissionsDto {
    permissions: UpdatePermissionDto[] | undefined;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    name!: string | undefined;
    isGranted!: boolean;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isGranted = data["isGranted"];
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        return data; 
    }
}

export interface IUpdatePermissionDto {
    name: string | undefined;
    isGranted: boolean;
}

export class ListResultDtoOfPurchaseOrderItemDto implements IListResultDtoOfPurchaseOrderItemDto {
    items!: PurchaseOrderItemDto[] | undefined;

    constructor(data?: IListResultDtoOfPurchaseOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PurchaseOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPurchaseOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPurchaseOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPurchaseOrderItemDto {
    items: PurchaseOrderItemDto[] | undefined;
}

export class PurchaseOrderItemDto extends EntityDtoOfGuid implements IPurchaseOrderItemDto {
    purchaseOrderNumber!: string | undefined;
    purchaseOrderSupplierName!: string | undefined;
    purchaseOrderOrderDate!: moment.Moment;
    purchaseOrderOrderState!: number;
    purchaseOrderId!: string;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitId!: string;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    quantity!: number;
    price!: number;
    taxRate!: number;
    priceWithTax!: number;
    money!: number;
    moneyWithTax!: number;
    inStockQuantity!: number;
    note!: string | undefined;

    constructor(data?: IPurchaseOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.purchaseOrderNumber = data["purchaseOrderNumber"];
            this.purchaseOrderSupplierName = data["purchaseOrderSupplierName"];
            this.purchaseOrderOrderDate = data["purchaseOrderOrderDate"] ? moment(data["purchaseOrderOrderDate"].toString()) : <any>undefined;
            this.purchaseOrderOrderState = data["purchaseOrderOrderState"];
            this.purchaseOrderId = data["purchaseOrderId"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitId = data["productBaseUnitId"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.quantity = data["quantity"];
            this.price = data["price"];
            this.taxRate = data["taxRate"];
            this.priceWithTax = data["priceWithTax"];
            this.money = data["money"];
            this.moneyWithTax = data["moneyWithTax"];
            this.inStockQuantity = data["inStockQuantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): PurchaseOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["purchaseOrderSupplierName"] = this.purchaseOrderSupplierName;
        data["purchaseOrderOrderDate"] = this.purchaseOrderOrderDate ? this.purchaseOrderOrderDate.toISOString() : <any>undefined;
        data["purchaseOrderOrderState"] = this.purchaseOrderOrderState;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitId"] = this.productBaseUnitId;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["priceWithTax"] = this.priceWithTax;
        data["money"] = this.money;
        data["moneyWithTax"] = this.moneyWithTax;
        data["inStockQuantity"] = this.inStockQuantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseOrderItemDto extends IEntityDtoOfGuid {
    purchaseOrderNumber: string | undefined;
    purchaseOrderSupplierName: string | undefined;
    purchaseOrderOrderDate: moment.Moment;
    purchaseOrderOrderState: number;
    purchaseOrderId: string;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitId: string;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    quantity: number;
    price: number;
    taxRate: number;
    priceWithTax: number;
    money: number;
    moneyWithTax: number;
    inStockQuantity: number;
    note: string | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;
    path!: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
            this.path = data["path"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        data["path"] = this.path;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
    path: string | undefined;
}

export class GetPurchaseReportInput implements IGetPurchaseReportInput {
    supplierName!: string | undefined;
    productName!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    orderStatus!: number | undefined;

    constructor(data?: IGetPurchaseReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supplierName = data["supplierName"];
            this.productName = data["productName"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.orderStatus = data["orderStatus"];
        }
    }

    static fromJS(data: any): GetPurchaseReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierName"] = this.supplierName;
        data["productName"] = this.productName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        return data; 
    }
}

export interface IGetPurchaseReportInput {
    supplierName: string | undefined;
    productName: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    orderStatus: number | undefined;
}

export class ListResultDtoOfPurchaseInOrderItemDto implements IListResultDtoOfPurchaseInOrderItemDto {
    items!: PurchaseInOrderItemDto[] | undefined;

    constructor(data?: IListResultDtoOfPurchaseInOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PurchaseInOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPurchaseInOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPurchaseInOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPurchaseInOrderItemDto {
    items: PurchaseInOrderItemDto[] | undefined;
}

export class PurchaseInOrderItemDto extends EntityDtoOfGuid implements IPurchaseInOrderItemDto {
    purchaseInOrderId!: string;
    purchaseInOrderNumber!: string | undefined;
    purchaseInOrderSupplierName!: string | undefined;
    purchaseInOrderOrderDate!: moment.Moment;
    purchaseInOrderOrderState!: number;
    sourceNumber!: string | undefined;
    sourceId!: string | undefined;
    sourceItemId!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitId!: string;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    warehouseId!: string;
    warehouseName!: string | undefined;
    quantity!: number;
    outStockQuantity!: number;
    note!: string | undefined;

    constructor(data?: IPurchaseInOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.purchaseInOrderId = data["purchaseInOrderId"];
            this.purchaseInOrderNumber = data["purchaseInOrderNumber"];
            this.purchaseInOrderSupplierName = data["purchaseInOrderSupplierName"];
            this.purchaseInOrderOrderDate = data["purchaseInOrderOrderDate"] ? moment(data["purchaseInOrderOrderDate"].toString()) : <any>undefined;
            this.purchaseInOrderOrderState = data["purchaseInOrderOrderState"];
            this.sourceNumber = data["sourceNumber"];
            this.sourceId = data["sourceId"];
            this.sourceItemId = data["sourceItemId"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitId = data["productBaseUnitId"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.quantity = data["quantity"];
            this.outStockQuantity = data["outStockQuantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): PurchaseInOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseInOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseInOrderId"] = this.purchaseInOrderId;
        data["purchaseInOrderNumber"] = this.purchaseInOrderNumber;
        data["purchaseInOrderSupplierName"] = this.purchaseInOrderSupplierName;
        data["purchaseInOrderOrderDate"] = this.purchaseInOrderOrderDate ? this.purchaseInOrderOrderDate.toISOString() : <any>undefined;
        data["purchaseInOrderOrderState"] = this.purchaseInOrderOrderState;
        data["sourceNumber"] = this.sourceNumber;
        data["sourceId"] = this.sourceId;
        data["sourceItemId"] = this.sourceItemId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitId"] = this.productBaseUnitId;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["outStockQuantity"] = this.outStockQuantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseInOrderItemDto extends IEntityDtoOfGuid {
    purchaseInOrderId: string;
    purchaseInOrderNumber: string | undefined;
    purchaseInOrderSupplierName: string | undefined;
    purchaseInOrderOrderDate: moment.Moment;
    purchaseInOrderOrderState: number;
    sourceNumber: string | undefined;
    sourceId: string | undefined;
    sourceItemId: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitId: string;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    warehouseId: string;
    warehouseName: string | undefined;
    quantity: number;
    outStockQuantity: number;
    note: string | undefined;
}

export class ListResultDtoOfPurchaseOutOrderItemDto implements IListResultDtoOfPurchaseOutOrderItemDto {
    items!: PurchaseOutOrderItemDto[] | undefined;

    constructor(data?: IListResultDtoOfPurchaseOutOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PurchaseOutOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPurchaseOutOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPurchaseOutOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPurchaseOutOrderItemDto {
    items: PurchaseOutOrderItemDto[] | undefined;
}

export class PurchaseOutOrderItemDto extends EntityDtoOfGuid implements IPurchaseOutOrderItemDto {
    purchaseOutOrderId!: string;
    purchaseOutOrderNumber!: string | undefined;
    purchaseOutOrderSupplierName!: string | undefined;
    purchaseOutOrderOrderDate!: moment.Moment;
    purchaseOutOrderOrderState!: number;
    sourceNumber!: string | undefined;
    sourceId!: string | undefined;
    sourceItemId!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitId!: string;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    warehouseId!: string;
    warehouseName!: string | undefined;
    quantity!: number;
    note!: string | undefined;

    constructor(data?: IPurchaseOutOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.purchaseOutOrderId = data["purchaseOutOrderId"];
            this.purchaseOutOrderNumber = data["purchaseOutOrderNumber"];
            this.purchaseOutOrderSupplierName = data["purchaseOutOrderSupplierName"];
            this.purchaseOutOrderOrderDate = data["purchaseOutOrderOrderDate"] ? moment(data["purchaseOutOrderOrderDate"].toString()) : <any>undefined;
            this.purchaseOutOrderOrderState = data["purchaseOutOrderOrderState"];
            this.sourceNumber = data["sourceNumber"];
            this.sourceId = data["sourceId"];
            this.sourceItemId = data["sourceItemId"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitId = data["productBaseUnitId"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.quantity = data["quantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): PurchaseOutOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOutOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOutOrderId"] = this.purchaseOutOrderId;
        data["purchaseOutOrderNumber"] = this.purchaseOutOrderNumber;
        data["purchaseOutOrderSupplierName"] = this.purchaseOutOrderSupplierName;
        data["purchaseOutOrderOrderDate"] = this.purchaseOutOrderOrderDate ? this.purchaseOutOrderOrderDate.toISOString() : <any>undefined;
        data["purchaseOutOrderOrderState"] = this.purchaseOutOrderOrderState;
        data["sourceNumber"] = this.sourceNumber;
        data["sourceId"] = this.sourceId;
        data["sourceItemId"] = this.sourceItemId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitId"] = this.productBaseUnitId;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseOutOrderItemDto extends IEntityDtoOfGuid {
    purchaseOutOrderId: string;
    purchaseOutOrderNumber: string | undefined;
    purchaseOutOrderSupplierName: string | undefined;
    purchaseOutOrderOrderDate: moment.Moment;
    purchaseOutOrderOrderState: number;
    sourceNumber: string | undefined;
    sourceId: string | undefined;
    sourceItemId: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitId: string;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    warehouseId: string;
    warehouseName: string | undefined;
    quantity: number;
    note: string | undefined;
}

export class ListResultDtoOfSaleOrderItemDto implements IListResultDtoOfSaleOrderItemDto {
    items!: SaleOrderItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSaleOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SaleOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSaleOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSaleOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSaleOrderItemDto {
    items: SaleOrderItemDto[] | undefined;
}

export class SaleOrderItemDto extends EntityDtoOfGuid implements ISaleOrderItemDto {
    saleOrderNumber!: string | undefined;
    saleOrderCustomerName!: string | undefined;
    saleOrderOrderDate!: moment.Moment;
    saleOrderOrderState!: number;
    saleOrderId!: string;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitId!: string;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    quantity!: number;
    price!: number;
    taxRate!: number;
    priceWithTax!: number;
    money!: number;
    moneyWithTax!: number;
    outStockQuantity!: number;
    note!: string | undefined;

    constructor(data?: ISaleOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.saleOrderNumber = data["saleOrderNumber"];
            this.saleOrderCustomerName = data["saleOrderCustomerName"];
            this.saleOrderOrderDate = data["saleOrderOrderDate"] ? moment(data["saleOrderOrderDate"].toString()) : <any>undefined;
            this.saleOrderOrderState = data["saleOrderOrderState"];
            this.saleOrderId = data["saleOrderId"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitId = data["productBaseUnitId"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.quantity = data["quantity"];
            this.price = data["price"];
            this.taxRate = data["taxRate"];
            this.priceWithTax = data["priceWithTax"];
            this.money = data["money"];
            this.moneyWithTax = data["moneyWithTax"];
            this.outStockQuantity = data["outStockQuantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): SaleOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleOrderNumber"] = this.saleOrderNumber;
        data["saleOrderCustomerName"] = this.saleOrderCustomerName;
        data["saleOrderOrderDate"] = this.saleOrderOrderDate ? this.saleOrderOrderDate.toISOString() : <any>undefined;
        data["saleOrderOrderState"] = this.saleOrderOrderState;
        data["saleOrderId"] = this.saleOrderId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitId"] = this.productBaseUnitId;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["priceWithTax"] = this.priceWithTax;
        data["money"] = this.money;
        data["moneyWithTax"] = this.moneyWithTax;
        data["outStockQuantity"] = this.outStockQuantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface ISaleOrderItemDto extends IEntityDtoOfGuid {
    saleOrderNumber: string | undefined;
    saleOrderCustomerName: string | undefined;
    saleOrderOrderDate: moment.Moment;
    saleOrderOrderState: number;
    saleOrderId: string;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitId: string;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    quantity: number;
    price: number;
    taxRate: number;
    priceWithTax: number;
    money: number;
    moneyWithTax: number;
    outStockQuantity: number;
    note: string | undefined;
}

export class GetSalesReportInput implements IGetSalesReportInput {
    customerName!: string | undefined;
    productName!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    orderStatus!: number | undefined;

    constructor(data?: IGetSalesReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerName = data["customerName"];
            this.productName = data["productName"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.orderStatus = data["orderStatus"];
        }
    }

    static fromJS(data: any): GetSalesReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerName"] = this.customerName;
        data["productName"] = this.productName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        return data; 
    }
}

export interface IGetSalesReportInput {
    customerName: string | undefined;
    productName: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    orderStatus: number | undefined;
}

export class ListResultDtoOfSaleInOrderItemDto implements IListResultDtoOfSaleInOrderItemDto {
    items!: SaleInOrderItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSaleInOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SaleInOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSaleInOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSaleInOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSaleInOrderItemDto {
    items: SaleInOrderItemDto[] | undefined;
}

export class SaleInOrderItemDto extends EntityDtoOfGuid implements ISaleInOrderItemDto {
    saleInOrderId!: string;
    saleInOrderNumber!: string | undefined;
    saleInOrderCustomerName!: string | undefined;
    saleInOrderOrderDate!: moment.Moment;
    saleInOrderOrderState!: number;
    sourceNumber!: string | undefined;
    sourceId!: string | undefined;
    sourceItemId!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitId!: string;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    warehouseId!: string;
    warehouseName!: string | undefined;
    quantity!: number;
    note!: string | undefined;

    constructor(data?: ISaleInOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.saleInOrderId = data["saleInOrderId"];
            this.saleInOrderNumber = data["saleInOrderNumber"];
            this.saleInOrderCustomerName = data["saleInOrderCustomerName"];
            this.saleInOrderOrderDate = data["saleInOrderOrderDate"] ? moment(data["saleInOrderOrderDate"].toString()) : <any>undefined;
            this.saleInOrderOrderState = data["saleInOrderOrderState"];
            this.sourceNumber = data["sourceNumber"];
            this.sourceId = data["sourceId"];
            this.sourceItemId = data["sourceItemId"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitId = data["productBaseUnitId"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.quantity = data["quantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): SaleInOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaleInOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleInOrderId"] = this.saleInOrderId;
        data["saleInOrderNumber"] = this.saleInOrderNumber;
        data["saleInOrderCustomerName"] = this.saleInOrderCustomerName;
        data["saleInOrderOrderDate"] = this.saleInOrderOrderDate ? this.saleInOrderOrderDate.toISOString() : <any>undefined;
        data["saleInOrderOrderState"] = this.saleInOrderOrderState;
        data["sourceNumber"] = this.sourceNumber;
        data["sourceId"] = this.sourceId;
        data["sourceItemId"] = this.sourceItemId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitId"] = this.productBaseUnitId;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface ISaleInOrderItemDto extends IEntityDtoOfGuid {
    saleInOrderId: string;
    saleInOrderNumber: string | undefined;
    saleInOrderCustomerName: string | undefined;
    saleInOrderOrderDate: moment.Moment;
    saleInOrderOrderState: number;
    sourceNumber: string | undefined;
    sourceId: string | undefined;
    sourceItemId: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitId: string;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    warehouseId: string;
    warehouseName: string | undefined;
    quantity: number;
    note: string | undefined;
}

export class ListResultDtoOfSaleOutOrderItemDto implements IListResultDtoOfSaleOutOrderItemDto {
    items!: SaleOutOrderItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSaleOutOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SaleOutOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSaleOutOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSaleOutOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSaleOutOrderItemDto {
    items: SaleOutOrderItemDto[] | undefined;
}

export class SaleOutOrderItemDto extends EntityDtoOfGuid implements ISaleOutOrderItemDto {
    saleOutOrderId!: string;
    saleOutOrderNumber!: string | undefined;
    saleOutOrderCustomerName!: string | undefined;
    saleOutOrderOrderDate!: moment.Moment;
    sourceNumber!: string | undefined;
    saleOutOrderOrderState!: number;
    sourceId!: string | undefined;
    sourceItemId!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitId!: string;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    warehouseId!: string;
    warehouseName!: string | undefined;
    quantity!: number;
    returnStockQuantity!: number;
    note!: string | undefined;

    constructor(data?: ISaleOutOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.saleOutOrderId = data["saleOutOrderId"];
            this.saleOutOrderNumber = data["saleOutOrderNumber"];
            this.saleOutOrderCustomerName = data["saleOutOrderCustomerName"];
            this.saleOutOrderOrderDate = data["saleOutOrderOrderDate"] ? moment(data["saleOutOrderOrderDate"].toString()) : <any>undefined;
            this.sourceNumber = data["sourceNumber"];
            this.saleOutOrderOrderState = data["saleOutOrderOrderState"];
            this.sourceId = data["sourceId"];
            this.sourceItemId = data["sourceItemId"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitId = data["productBaseUnitId"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.quantity = data["quantity"];
            this.returnStockQuantity = data["returnStockQuantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): SaleOutOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOutOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleOutOrderId"] = this.saleOutOrderId;
        data["saleOutOrderNumber"] = this.saleOutOrderNumber;
        data["saleOutOrderCustomerName"] = this.saleOutOrderCustomerName;
        data["saleOutOrderOrderDate"] = this.saleOutOrderOrderDate ? this.saleOutOrderOrderDate.toISOString() : <any>undefined;
        data["sourceNumber"] = this.sourceNumber;
        data["saleOutOrderOrderState"] = this.saleOutOrderOrderState;
        data["sourceId"] = this.sourceId;
        data["sourceItemId"] = this.sourceItemId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitId"] = this.productBaseUnitId;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["returnStockQuantity"] = this.returnStockQuantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface ISaleOutOrderItemDto extends IEntityDtoOfGuid {
    saleOutOrderId: string;
    saleOutOrderNumber: string | undefined;
    saleOutOrderCustomerName: string | undefined;
    saleOutOrderOrderDate: moment.Moment;
    sourceNumber: string | undefined;
    saleOutOrderOrderState: number;
    sourceId: string | undefined;
    sourceItemId: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitId: string;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    warehouseId: string;
    warehouseName: string | undefined;
    quantity: number;
    returnStockQuantity: number;
    note: string | undefined;
}

export class ListResultDtoOfSalesProductRankingDto implements IListResultDtoOfSalesProductRankingDto {
    items!: SalesProductRankingDto[] | undefined;

    constructor(data?: IListResultDtoOfSalesProductRankingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SalesProductRankingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSalesProductRankingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSalesProductRankingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSalesProductRankingDto {
    items: SalesProductRankingDto[] | undefined;
}

export class SalesProductRankingDto implements ISalesProductRankingDto {
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    quantity!: number;

    constructor(data?: ISalesProductRankingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.quantity = data["quantity"];
        }
    }

    static fromJS(data: any): SalesProductRankingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesProductRankingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["quantity"] = this.quantity;
        return data; 
    }
}

export interface ISalesProductRankingDto {
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    quantity: number;
}

export class WarehouseDto extends EntityDtoOfGuid implements IWarehouseDto {
    name!: string | undefined;

    constructor(data?: IWarehouseDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): WarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        super.toJSON(data);
        return data; 
    }
}

export interface IWarehouseDto extends IEntityDtoOfGuid {
    name: string | undefined;
}

export class ListResultDtoOfWarehouseDto implements IListResultDtoOfWarehouseDto {
    items!: WarehouseDto[] | undefined;

    constructor(data?: IListResultDtoOfWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WarehouseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfWarehouseDto {
    items: WarehouseDto[] | undefined;
}

export class PagedResultDtoOfWarehouseDto extends ListResultDtoOfWarehouseDto implements IPagedResultDtoOfWarehouseDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfWarehouseDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfWarehouseDto extends IListResultDtoOfWarehouseDto {
    totalCount: number;
}

export class ConditionItem implements IConditionItem {
    field!: string | undefined;
    method!: Operator;
    value!: string | undefined;
    valueType!: ValueType;
    orGroup!: string | undefined;
    navigationListProperty!: string | undefined;

    constructor(data?: IConditionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.method = data["method"];
            this.value = data["value"];
            this.valueType = data["valueType"];
            this.orGroup = data["orGroup"];
            this.navigationListProperty = data["navigationListProperty"];
        }
    }

    static fromJS(data: any): ConditionItem {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["method"] = this.method;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        data["orGroup"] = this.orGroup;
        data["navigationListProperty"] = this.navigationListProperty;
        return data; 
    }
}

export interface IConditionItem {
    field: string | undefined;
    method: Operator;
    value: string | undefined;
    valueType: ValueType;
    orGroup: string | undefined;
    navigationListProperty: string | undefined;
}

export enum Operator {
    Equal = 0,
    LessThan = 1,
    GreaterThan = 2,
    LessThanOrEqual = 3,
    GreaterThanOrEqual = 4,
    NotEqual = 5,
    In = 6,
    Contains = 7,
    Included = 8,
}

export enum ValueType {
    String = 0,
    Array = 1,
}

export class UnitDto extends EntityDtoOfGuid implements IUnitDto {
    groupName!: string | undefined;
    name!: string | undefined;
    baseUnitName!: string | undefined;
    rate!: number;
    conversionType!: number;

    constructor(data?: IUnitDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.groupName = data["groupName"];
            this.name = data["name"];
            this.baseUnitName = data["baseUnitName"];
            this.rate = data["rate"];
            this.conversionType = data["conversionType"];
        }
    }

    static fromJS(data: any): UnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["baseUnitName"] = this.baseUnitName;
        data["rate"] = this.rate;
        data["conversionType"] = this.conversionType;
        super.toJSON(data);
        return data; 
    }
}

export interface IUnitDto extends IEntityDtoOfGuid {
    groupName: string | undefined;
    name: string | undefined;
    baseUnitName: string | undefined;
    rate: number;
    conversionType: number;
}

export class ListResultDtoOfUnitDto implements IListResultDtoOfUnitDto {
    items!: UnitDto[] | undefined;

    constructor(data?: IListResultDtoOfUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUnitDto {
    items: UnitDto[] | undefined;
}

export class PagedResultDtoOfUnitDto extends ListResultDtoOfUnitDto implements IPagedResultDtoOfUnitDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfUnitDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfUnitDto extends IListResultDtoOfUnitDto {
    totalCount: number;
}

export class SupplierDto extends EntityDtoOfGuid implements ISupplierDto {
    code!: string | undefined;
    name!: string | undefined;
    defaultContact!: ContactPerson | undefined;
    address!: string | undefined;
    isActive!: boolean;
    supplierContacts!: SupplierContactDto[] | undefined;
    attachments!: AttachmentInfo[] | undefined;

    constructor(data?: ISupplierDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.defaultContact = data["defaultContact"] ? ContactPerson.fromJS(data["defaultContact"]) : <any>undefined;
            this.address = data["address"];
            this.isActive = data["isActive"];
            if (Array.isArray(data["supplierContacts"])) {
                this.supplierContacts = [] as any;
                for (let item of data["supplierContacts"])
                    this.supplierContacts!.push(SupplierContactDto.fromJS(item));
            }
            if (Array.isArray(data["attachments"])) {
                this.attachments = [] as any;
                for (let item of data["attachments"])
                    this.attachments!.push(AttachmentInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["defaultContact"] = this.defaultContact ? this.defaultContact.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.supplierContacts)) {
            data["supplierContacts"] = [];
            for (let item of this.supplierContacts)
                data["supplierContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISupplierDto extends IEntityDtoOfGuid {
    code: string | undefined;
    name: string | undefined;
    defaultContact: ContactPerson | undefined;
    address: string | undefined;
    isActive: boolean;
    supplierContacts: SupplierContactDto[] | undefined;
    attachments: AttachmentInfo[] | undefined;
}

export abstract class ValueObject implements IValueObject {

    constructor(data?: IValueObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): ValueObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ValueObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IValueObject {
}

export class ContactPerson extends ValueObject implements IContactPerson {
    name!: string | undefined;
    gender!: string | undefined;
    post!: string | undefined;
    email!: string | undefined;
    telPhone!: string | undefined;
    qq!: string | undefined;
    weiXin!: string | undefined;

    constructor(data?: IContactPerson) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.gender = data["gender"];
            this.post = data["post"];
            this.email = data["email"];
            this.telPhone = data["telPhone"];
            this.qq = data["qq"];
            this.weiXin = data["weiXin"];
        }
    }

    static fromJS(data: any): ContactPerson {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["gender"] = this.gender;
        data["post"] = this.post;
        data["email"] = this.email;
        data["telPhone"] = this.telPhone;
        data["qq"] = this.qq;
        data["weiXin"] = this.weiXin;
        super.toJSON(data);
        return data; 
    }
}

export interface IContactPerson extends IValueObject {
    name: string | undefined;
    gender: string | undefined;
    post: string | undefined;
    email: string | undefined;
    telPhone: string | undefined;
    qq: string | undefined;
    weiXin: string | undefined;
}

export class SupplierContactDto extends EntityDtoOfGuid implements ISupplierContactDto {
    supplierId!: string;
    supplierName!: string | undefined;
    contact!: ContactPerson | undefined;
    note!: string | undefined;
    isDefault!: boolean;

    constructor(data?: ISupplierContactDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.contact = data["contact"] ? ContactPerson.fromJS(data["contact"]) : <any>undefined;
            this.note = data["note"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): SupplierContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["note"] = this.note;
        data["isDefault"] = this.isDefault;
        super.toJSON(data);
        return data; 
    }
}

export interface ISupplierContactDto extends IEntityDtoOfGuid {
    supplierId: string;
    supplierName: string | undefined;
    contact: ContactPerson | undefined;
    note: string | undefined;
    isDefault: boolean;
}

export class AttachmentInfo implements IAttachmentInfo {
    id!: string;
    entityId!: string | undefined;
    entityTypeName!: string | undefined;
    fileName!: string | undefined;
    fileSize!: number;
    fileType!: string | undefined;
    fileSuffix!: string | undefined;
    storePath!: string | undefined;

    constructor(data?: IAttachmentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.entityId = data["entityId"];
            this.entityTypeName = data["entityTypeName"];
            this.fileName = data["fileName"];
            this.fileSize = data["fileSize"];
            this.fileType = data["fileType"];
            this.fileSuffix = data["fileSuffix"];
            this.storePath = data["storePath"];
        }
    }

    static fromJS(data: any): AttachmentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityId"] = this.entityId;
        data["entityTypeName"] = this.entityTypeName;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["fileType"] = this.fileType;
        data["fileSuffix"] = this.fileSuffix;
        data["storePath"] = this.storePath;
        return data; 
    }
}

export interface IAttachmentInfo {
    id: string;
    entityId: string | undefined;
    entityTypeName: string | undefined;
    fileName: string | undefined;
    fileSize: number;
    fileType: string | undefined;
    fileSuffix: string | undefined;
    storePath: string | undefined;
}

export class ListResultDtoOfSupplierDto implements IListResultDtoOfSupplierDto {
    items!: SupplierDto[] | undefined;

    constructor(data?: IListResultDtoOfSupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupplierDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSupplierDto {
    items: SupplierDto[] | undefined;
}

export class PagedResultDtoOfSupplierDto extends ListResultDtoOfSupplierDto implements IPagedResultDtoOfSupplierDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfSupplierDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfSupplierDto extends IListResultDtoOfSupplierDto {
    totalCount: number;
}

export class DynamicQueryInput implements IDynamicQueryInput {
    items!: ConditionItem[] | undefined;
    maxResultCount!: number;
    skipCount!: number;
    sorting!: string | undefined;

    constructor(data?: IDynamicQueryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ConditionItem.fromJS(item));
            }
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
        }
    }

    static fromJS(data: any): DynamicQueryInput {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicQueryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        return data; 
    }
}

export interface IDynamicQueryInput {
    items: ConditionItem[] | undefined;
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
}

export class ListResultDtoOfSupplierPriceDto implements IListResultDtoOfSupplierPriceDto {
    items!: SupplierPriceDto[] | undefined;

    constructor(data?: IListResultDtoOfSupplierPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupplierPriceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSupplierPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSupplierPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSupplierPriceDto {
    items: SupplierPriceDto[] | undefined;
}

export class PagedResultDtoOfSupplierPriceDto extends ListResultDtoOfSupplierPriceDto implements IPagedResultDtoOfSupplierPriceDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfSupplierPriceDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupplierPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupplierPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfSupplierPriceDto extends IListResultDtoOfSupplierPriceDto {
    totalCount: number;
}

export class SupplierPriceDto implements ISupplierPriceDto {
    supplierId!: string;
    productId!: string;
    unitId!: string;
    moreThanQuantity!: number;
    price!: number;
    taxRate!: number;
    priceWithTax!: number;
    supplier!: SimpleSupplierDto | undefined;
    product!: SimpleProductDto | undefined;
    unit!: UnitDto | undefined;

    constructor(data?: ISupplierPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supplierId = data["supplierId"];
            this.productId = data["productId"];
            this.unitId = data["unitId"];
            this.moreThanQuantity = data["moreThanQuantity"];
            this.price = data["price"];
            this.taxRate = data["taxRate"];
            this.priceWithTax = data["priceWithTax"];
            this.supplier = data["supplier"] ? SimpleSupplierDto.fromJS(data["supplier"]) : <any>undefined;
            this.product = data["product"] ? SimpleProductDto.fromJS(data["product"]) : <any>undefined;
            this.unit = data["unit"] ? UnitDto.fromJS(data["unit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SupplierPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["productId"] = this.productId;
        data["unitId"] = this.unitId;
        data["moreThanQuantity"] = this.moreThanQuantity;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["priceWithTax"] = this.priceWithTax;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISupplierPriceDto {
    supplierId: string;
    productId: string;
    unitId: string;
    moreThanQuantity: number;
    price: number;
    taxRate: number;
    priceWithTax: number;
    supplier: SimpleSupplierDto | undefined;
    product: SimpleProductDto | undefined;
    unit: UnitDto | undefined;
}

export class SimpleSupplierDto implements ISimpleSupplierDto {
    code!: string | undefined;
    name!: string | undefined;
    defaultContact!: ContactPerson | undefined;
    address!: string | undefined;
    isActive!: boolean;

    constructor(data?: ISimpleSupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.defaultContact = data["defaultContact"] ? ContactPerson.fromJS(data["defaultContact"]) : <any>undefined;
            this.address = data["address"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): SimpleSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["defaultContact"] = this.defaultContact ? this.defaultContact.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ISimpleSupplierDto {
    code: string | undefined;
    name: string | undefined;
    defaultContact: ContactPerson | undefined;
    address: string | undefined;
    isActive: boolean;
}

export class SimpleProductDto implements ISimpleProductDto {
    productCategoryId!: string;
    productCategoryName!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    spec!: string | undefined;
    warehouseId!: string | undefined;
    warehouseName!: string | undefined;
    unitGroupName!: string | undefined;
    baseUnitId!: string;
    baseUnitName!: string | undefined;

    constructor(data?: ISimpleProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productCategoryId = data["productCategoryId"];
            this.productCategoryName = data["productCategoryName"];
            this.code = data["code"];
            this.name = data["name"];
            this.spec = data["spec"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.unitGroupName = data["unitGroupName"];
            this.baseUnitId = data["baseUnitId"];
            this.baseUnitName = data["baseUnitName"];
        }
    }

    static fromJS(data: any): SimpleProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategoryId"] = this.productCategoryId;
        data["productCategoryName"] = this.productCategoryName;
        data["code"] = this.code;
        data["name"] = this.name;
        data["spec"] = this.spec;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["unitGroupName"] = this.unitGroupName;
        data["baseUnitId"] = this.baseUnitId;
        data["baseUnitName"] = this.baseUnitName;
        return data; 
    }
}

export interface ISimpleProductDto {
    productCategoryId: string;
    productCategoryName: string | undefined;
    code: string | undefined;
    name: string | undefined;
    spec: string | undefined;
    warehouseId: string | undefined;
    warehouseName: string | undefined;
    unitGroupName: string | undefined;
    baseUnitId: string;
    baseUnitName: string | undefined;
}

export class StoreTransferDto extends EntityDtoOfGuid implements IStoreTransferDto {
    number!: string | undefined;
    fromWarehouseId!: string;
    toWarehouseId!: string;
    orderDate!: moment.Moment;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    remark!: string | undefined;
    fromWarehouse!: WarehouseDto | undefined;
    toWarehouse!: WarehouseDto | undefined;
    storeTransferItems!: StoreTransferItemDto[] | undefined;

    constructor(data?: IStoreTransferDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.fromWarehouseId = data["fromWarehouseId"];
            this.toWarehouseId = data["toWarehouseId"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.remark = data["remark"];
            this.fromWarehouse = data["fromWarehouse"] ? WarehouseDto.fromJS(data["fromWarehouse"]) : <any>undefined;
            this.toWarehouse = data["toWarehouse"] ? WarehouseDto.fromJS(data["toWarehouse"]) : <any>undefined;
            if (Array.isArray(data["storeTransferItems"])) {
                this.storeTransferItems = [] as any;
                for (let item of data["storeTransferItems"])
                    this.storeTransferItems!.push(StoreTransferItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoreTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["fromWarehouseId"] = this.fromWarehouseId;
        data["toWarehouseId"] = this.toWarehouseId;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["remark"] = this.remark;
        data["fromWarehouse"] = this.fromWarehouse ? this.fromWarehouse.toJSON() : <any>undefined;
        data["toWarehouse"] = this.toWarehouse ? this.toWarehouse.toJSON() : <any>undefined;
        if (Array.isArray(this.storeTransferItems)) {
            data["storeTransferItems"] = [];
            for (let item of this.storeTransferItems)
                data["storeTransferItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IStoreTransferDto extends IEntityDtoOfGuid {
    number: string | undefined;
    fromWarehouseId: string;
    toWarehouseId: string;
    orderDate: moment.Moment;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    remark: string | undefined;
    fromWarehouse: WarehouseDto | undefined;
    toWarehouse: WarehouseDto | undefined;
    storeTransferItems: StoreTransferItemDto[] | undefined;
}

export class StoreTransferItemDto extends EntityDtoOfGuid implements IStoreTransferItemDto {
    productId!: string;
    unitId!: string;
    unitRate!: number;
    quantity!: number;
    remark!: string | undefined;
    product!: ProductDto | undefined;
    unit!: UnitDto | undefined;

    constructor(data?: IStoreTransferItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.productId = data["productId"];
            this.unitId = data["unitId"];
            this.unitRate = data["unitRate"];
            this.quantity = data["quantity"];
            this.remark = data["remark"];
            this.product = data["product"] ? ProductDto.fromJS(data["product"]) : <any>undefined;
            this.unit = data["unit"] ? UnitDto.fromJS(data["unit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreTransferItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTransferItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["unitId"] = this.unitId;
        data["unitRate"] = this.unitRate;
        data["quantity"] = this.quantity;
        data["remark"] = this.remark;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IStoreTransferItemDto extends IEntityDtoOfGuid {
    productId: string;
    unitId: string;
    unitRate: number;
    quantity: number;
    remark: string | undefined;
    product: ProductDto | undefined;
    unit: UnitDto | undefined;
}

export class ProductDto extends EntityDtoOfGuid implements IProductDto {
    productCategoryId!: string;
    productCategoryName!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    spec!: string | undefined;
    type!: number;
    warehouseId!: string | undefined;
    warehouseName!: string | undefined;
    unitGroupName!: string | undefined;
    baseUnitId!: string;
    baseUnitName!: string | undefined;
    purchaseUnitId!: string | undefined;
    purchaseUnitName!: string | undefined;
    purchaseUnitRate!: number;
    saleUnitId!: string | undefined;
    saleUnitName!: string | undefined;
    saleUnitRate!: number;
    storeUnitId!: string | undefined;
    storeUnitName!: string | undefined;
    storeUnitRate!: number;
    costPrice!: number;
    salePrice!: number;
    taxRate!: number;
    note!: string | undefined;
    isActive!: boolean;
    attachments!: AttachmentInfo[] | undefined;

    constructor(data?: IProductDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.productCategoryId = data["productCategoryId"];
            this.productCategoryName = data["productCategoryName"];
            this.code = data["code"];
            this.name = data["name"];
            this.spec = data["spec"];
            this.type = data["type"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.unitGroupName = data["unitGroupName"];
            this.baseUnitId = data["baseUnitId"];
            this.baseUnitName = data["baseUnitName"];
            this.purchaseUnitId = data["purchaseUnitId"];
            this.purchaseUnitName = data["purchaseUnitName"];
            this.purchaseUnitRate = data["purchaseUnitRate"];
            this.saleUnitId = data["saleUnitId"];
            this.saleUnitName = data["saleUnitName"];
            this.saleUnitRate = data["saleUnitRate"];
            this.storeUnitId = data["storeUnitId"];
            this.storeUnitName = data["storeUnitName"];
            this.storeUnitRate = data["storeUnitRate"];
            this.costPrice = data["costPrice"];
            this.salePrice = data["salePrice"];
            this.taxRate = data["taxRate"];
            this.note = data["note"];
            this.isActive = data["isActive"];
            if (Array.isArray(data["attachments"])) {
                this.attachments = [] as any;
                for (let item of data["attachments"])
                    this.attachments!.push(AttachmentInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategoryId"] = this.productCategoryId;
        data["productCategoryName"] = this.productCategoryName;
        data["code"] = this.code;
        data["name"] = this.name;
        data["spec"] = this.spec;
        data["type"] = this.type;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["unitGroupName"] = this.unitGroupName;
        data["baseUnitId"] = this.baseUnitId;
        data["baseUnitName"] = this.baseUnitName;
        data["purchaseUnitId"] = this.purchaseUnitId;
        data["purchaseUnitName"] = this.purchaseUnitName;
        data["purchaseUnitRate"] = this.purchaseUnitRate;
        data["saleUnitId"] = this.saleUnitId;
        data["saleUnitName"] = this.saleUnitName;
        data["saleUnitRate"] = this.saleUnitRate;
        data["storeUnitId"] = this.storeUnitId;
        data["storeUnitName"] = this.storeUnitName;
        data["storeUnitRate"] = this.storeUnitRate;
        data["costPrice"] = this.costPrice;
        data["salePrice"] = this.salePrice;
        data["taxRate"] = this.taxRate;
        data["note"] = this.note;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IProductDto extends IEntityDtoOfGuid {
    productCategoryId: string;
    productCategoryName: string | undefined;
    code: string | undefined;
    name: string | undefined;
    spec: string | undefined;
    type: number;
    warehouseId: string | undefined;
    warehouseName: string | undefined;
    unitGroupName: string | undefined;
    baseUnitId: string;
    baseUnitName: string | undefined;
    purchaseUnitId: string | undefined;
    purchaseUnitName: string | undefined;
    purchaseUnitRate: number;
    saleUnitId: string | undefined;
    saleUnitName: string | undefined;
    saleUnitRate: number;
    storeUnitId: string | undefined;
    storeUnitName: string | undefined;
    storeUnitRate: number;
    costPrice: number;
    salePrice: number;
    taxRate: number;
    note: string | undefined;
    isActive: boolean;
    attachments: AttachmentInfo[] | undefined;
}

export class ListResultDtoOfStoreTransferDto implements IListResultDtoOfStoreTransferDto {
    items!: StoreTransferDto[] | undefined;

    constructor(data?: IListResultDtoOfStoreTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(StoreTransferDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfStoreTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfStoreTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfStoreTransferDto {
    items: StoreTransferDto[] | undefined;
}

export class PagedResultDtoOfStoreTransferDto extends ListResultDtoOfStoreTransferDto implements IPagedResultDtoOfStoreTransferDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfStoreTransferDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfStoreTransferDto extends IListResultDtoOfStoreTransferDto {
    totalCount: number;
}

export class PSISettingsEditDto implements IPSISettingsEditDto {
    multipleUnit!: string | undefined;
    priceDecimalPrecision!: string | undefined;
    moneyDecimalPrecision!: string | undefined;

    constructor(data?: IPSISettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.multipleUnit = data["multipleUnit"];
            this.priceDecimalPrecision = data["priceDecimalPrecision"];
            this.moneyDecimalPrecision = data["moneyDecimalPrecision"];
        }
    }

    static fromJS(data: any): PSISettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PSISettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multipleUnit"] = this.multipleUnit;
        data["priceDecimalPrecision"] = this.priceDecimalPrecision;
        data["moneyDecimalPrecision"] = this.moneyDecimalPrecision;
        return data; 
    }
}

export interface IPSISettingsEditDto {
    multipleUnit: string | undefined;
    priceDecimalPrecision: string | undefined;
    moneyDecimalPrecision: string | undefined;
}

export class SaleOutOrderDto extends EntityDtoOfGuid implements ISaleOutOrderDto {
    number!: string | undefined;
    orderDate!: moment.Moment;
    customerId!: string;
    contact!: string | undefined;
    contactTel!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    warehouseId!: string;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    customer!: SimpleCustomerDto | undefined;
    saleOutOrderItems!: SaleOutOrderItemDto[] | undefined;

    constructor(data?: ISaleOutOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.contact = data["contact"];
            this.contactTel = data["contactTel"];
            this.address = data["address"];
            this.note = data["note"];
            this.warehouseId = data["warehouseId"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.customer = data["customer"] ? SimpleCustomerDto.fromJS(data["customer"]) : <any>undefined;
            if (Array.isArray(data["saleOutOrderItems"])) {
                this.saleOutOrderItems = [] as any;
                for (let item of data["saleOutOrderItems"])
                    this.saleOutOrderItems!.push(SaleOutOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["contact"] = this.contact;
        data["contactTel"] = this.contactTel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["warehouseId"] = this.warehouseId;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.saleOutOrderItems)) {
            data["saleOutOrderItems"] = [];
            for (let item of this.saleOutOrderItems)
                data["saleOutOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISaleOutOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    orderDate: moment.Moment;
    customerId: string;
    contact: string | undefined;
    contactTel: string | undefined;
    address: string | undefined;
    note: string | undefined;
    warehouseId: string;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    customer: SimpleCustomerDto | undefined;
    saleOutOrderItems: SaleOutOrderItemDto[] | undefined;
}

export class SimpleCustomerDto extends EntityDtoOfGuid implements ISimpleCustomerDto {
    code!: string | undefined;
    name!: string | undefined;
    defaultContact!: ContactPerson | undefined;
    address!: string | undefined;
    isActive!: boolean;

    constructor(data?: ISimpleCustomerDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.defaultContact = data["defaultContact"] ? ContactPerson.fromJS(data["defaultContact"]) : <any>undefined;
            this.address = data["address"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): SimpleCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["defaultContact"] = this.defaultContact ? this.defaultContact.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        super.toJSON(data);
        return data; 
    }
}

export interface ISimpleCustomerDto extends IEntityDtoOfGuid {
    code: string | undefined;
    name: string | undefined;
    defaultContact: ContactPerson | undefined;
    address: string | undefined;
    isActive: boolean;
}

export class ListResultDtoOfSaleOutOrderDto implements IListResultDtoOfSaleOutOrderDto {
    items!: SaleOutOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfSaleOutOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SaleOutOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSaleOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSaleOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSaleOutOrderDto {
    items: SaleOutOrderDto[] | undefined;
}

export class PagedResultDtoOfSaleOutOrderDto extends ListResultDtoOfSaleOutOrderDto implements IPagedResultDtoOfSaleOutOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfSaleOutOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfSaleOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSaleOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfSaleOutOrderDto extends IListResultDtoOfSaleOutOrderDto {
    totalCount: number;
}

export class SaleOrderDto extends EntityDtoOfGuid implements ISaleOrderDto {
    number!: string | undefined;
    poNumber!: string | undefined;
    customerId!: string;
    contact!: string | undefined;
    contactTel!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    orderDate!: moment.Moment;
    salesId!: string;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    customer!: SimpleCustomerDto | undefined;
    saleOrderItems!: SaleOrderItemDto[] | undefined;
    saleOutOrderItems!: SaleOutOrderItemDto[] | undefined;

    constructor(data?: ISaleOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.poNumber = data["poNumber"];
            this.customerId = data["customerId"];
            this.contact = data["contact"];
            this.contactTel = data["contactTel"];
            this.address = data["address"];
            this.note = data["note"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.salesId = data["salesId"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.customer = data["customer"] ? SimpleCustomerDto.fromJS(data["customer"]) : <any>undefined;
            if (Array.isArray(data["saleOrderItems"])) {
                this.saleOrderItems = [] as any;
                for (let item of data["saleOrderItems"])
                    this.saleOrderItems!.push(SaleOrderItemDto.fromJS(item));
            }
            if (Array.isArray(data["saleOutOrderItems"])) {
                this.saleOutOrderItems = [] as any;
                for (let item of data["saleOutOrderItems"])
                    this.saleOutOrderItems!.push(SaleOutOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["poNumber"] = this.poNumber;
        data["customerId"] = this.customerId;
        data["contact"] = this.contact;
        data["contactTel"] = this.contactTel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["salesId"] = this.salesId;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.saleOrderItems)) {
            data["saleOrderItems"] = [];
            for (let item of this.saleOrderItems)
                data["saleOrderItems"].push(item.toJSON());
        }
        if (Array.isArray(this.saleOutOrderItems)) {
            data["saleOutOrderItems"] = [];
            for (let item of this.saleOutOrderItems)
                data["saleOutOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISaleOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    poNumber: string | undefined;
    customerId: string;
    contact: string | undefined;
    contactTel: string | undefined;
    address: string | undefined;
    note: string | undefined;
    orderDate: moment.Moment;
    salesId: string;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    customer: SimpleCustomerDto | undefined;
    saleOrderItems: SaleOrderItemDto[] | undefined;
    saleOutOrderItems: SaleOutOrderItemDto[] | undefined;
}

export class ListResultDtoOfSaleOrderDto implements IListResultDtoOfSaleOrderDto {
    items!: SaleOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfSaleOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SaleOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSaleOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSaleOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSaleOrderDto {
    items: SaleOrderDto[] | undefined;
}

export class PagedResultDtoOfSaleOrderDto extends ListResultDtoOfSaleOrderDto implements IPagedResultDtoOfSaleOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfSaleOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfSaleOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSaleOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfSaleOrderDto extends IListResultDtoOfSaleOrderDto {
    totalCount: number;
}

export class SaleInOrderDto extends EntityDtoOfGuid implements ISaleInOrderDto {
    number!: string | undefined;
    orderDate!: moment.Moment;
    customerId!: string;
    contact!: string | undefined;
    contactTel!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    warehouseId!: string;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    customer!: SimpleCustomerDto | undefined;
    saleInOrderItems!: SaleInOrderItemDto[] | undefined;

    constructor(data?: ISaleInOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.contact = data["contact"];
            this.contactTel = data["contactTel"];
            this.address = data["address"];
            this.note = data["note"];
            this.warehouseId = data["warehouseId"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.customer = data["customer"] ? SimpleCustomerDto.fromJS(data["customer"]) : <any>undefined;
            if (Array.isArray(data["saleInOrderItems"])) {
                this.saleInOrderItems = [] as any;
                for (let item of data["saleInOrderItems"])
                    this.saleInOrderItems!.push(SaleInOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaleInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["contact"] = this.contact;
        data["contactTel"] = this.contactTel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["warehouseId"] = this.warehouseId;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.saleInOrderItems)) {
            data["saleInOrderItems"] = [];
            for (let item of this.saleInOrderItems)
                data["saleInOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISaleInOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    orderDate: moment.Moment;
    customerId: string;
    contact: string | undefined;
    contactTel: string | undefined;
    address: string | undefined;
    note: string | undefined;
    warehouseId: string;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    customer: SimpleCustomerDto | undefined;
    saleInOrderItems: SaleInOrderItemDto[] | undefined;
}

export class ListResultDtoOfSaleInOrderDto implements IListResultDtoOfSaleInOrderDto {
    items!: SaleInOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfSaleInOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SaleInOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSaleInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSaleInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSaleInOrderDto {
    items: SaleInOrderDto[] | undefined;
}

export class PagedResultDtoOfSaleInOrderDto extends ListResultDtoOfSaleInOrderDto implements IPagedResultDtoOfSaleInOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfSaleInOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfSaleInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSaleInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfSaleInOrderDto extends IListResultDtoOfSaleInOrderDto {
    totalCount: number;
}

export class SafetyStockDto implements ISafetyStockDto {
    id!: string;
    productId!: string;
    warehouseId!: string;
    minQuantity!: number | undefined;
    maxQuantity!: number | undefined;
    warehouse!: WarehouseDto | undefined;
    product!: SimpleProductDto | undefined;

    constructor(data?: ISafetyStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.productId = data["productId"];
            this.warehouseId = data["warehouseId"];
            this.minQuantity = data["minQuantity"];
            this.maxQuantity = data["maxQuantity"];
            this.warehouse = data["warehouse"] ? WarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
            this.product = data["product"] ? SimpleProductDto.fromJS(data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SafetyStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new SafetyStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["minQuantity"] = this.minQuantity;
        data["maxQuantity"] = this.maxQuantity;
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISafetyStockDto {
    id: string;
    productId: string;
    warehouseId: string;
    minQuantity: number | undefined;
    maxQuantity: number | undefined;
    warehouse: WarehouseDto | undefined;
    product: SimpleProductDto | undefined;
}

export class ListResultDtoOfSafetyStockDto implements IListResultDtoOfSafetyStockDto {
    items!: SafetyStockDto[] | undefined;

    constructor(data?: IListResultDtoOfSafetyStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SafetyStockDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSafetyStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSafetyStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSafetyStockDto {
    items: SafetyStockDto[] | undefined;
}

export class PagedResultDtoOfSafetyStockDto extends ListResultDtoOfSafetyStockDto implements IPagedResultDtoOfSafetyStockDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfSafetyStockDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfSafetyStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSafetyStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfSafetyStockDto extends IListResultDtoOfSafetyStockDto {
    totalCount: number;
}

export class ListResultDtoOfSafetyStockWarningDto implements IListResultDtoOfSafetyStockWarningDto {
    items!: SafetyStockWarningDto[] | undefined;

    constructor(data?: IListResultDtoOfSafetyStockWarningDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SafetyStockWarningDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSafetyStockWarningDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSafetyStockWarningDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSafetyStockWarningDto {
    items: SafetyStockWarningDto[] | undefined;
}

export class PagedResultDtoOfSafetyStockWarningDto extends ListResultDtoOfSafetyStockWarningDto implements IPagedResultDtoOfSafetyStockWarningDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfSafetyStockWarningDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfSafetyStockWarningDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSafetyStockWarningDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfSafetyStockWarningDto extends IListResultDtoOfSafetyStockWarningDto {
    totalCount: number;
}

export class SafetyStockWarningDto implements ISafetyStockWarningDto {
    productId!: string;
    warehouseId!: string;
    stockQuantity!: number | undefined;
    minQuantity!: number | undefined;
    maxQuantity!: number | undefined;
    warehouse!: WarehouseDto | undefined;
    product!: SimpleProductDto | undefined;

    constructor(data?: ISafetyStockWarningDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.warehouseId = data["warehouseId"];
            this.stockQuantity = data["stockQuantity"];
            this.minQuantity = data["minQuantity"];
            this.maxQuantity = data["maxQuantity"];
            this.warehouse = data["warehouse"] ? WarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
            this.product = data["product"] ? SimpleProductDto.fromJS(data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SafetyStockWarningDto {
        data = typeof data === 'object' ? data : {};
        let result = new SafetyStockWarningDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["stockQuantity"] = this.stockQuantity;
        data["minQuantity"] = this.minQuantity;
        data["maxQuantity"] = this.maxQuantity;
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISafetyStockWarningDto {
    productId: string;
    warehouseId: string;
    stockQuantity: number | undefined;
    minQuantity: number | undefined;
    maxQuantity: number | undefined;
    warehouse: WarehouseDto | undefined;
    product: SimpleProductDto | undefined;
}

export class QuotationOrderDto extends EntityDtoOfGuid implements IQuotationOrderDto {
    number!: string | undefined;
    orderDate!: moment.Moment;
    isPublished!: boolean;
    publishDate!: moment.Moment;
    customerId!: string;
    contact!: string | undefined;
    contactTel!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    customer!: SimpleCustomerDto | undefined;
    quotationOrderItems!: QuotationOrderItemDto[] | undefined;

    constructor(data?: IQuotationOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.isPublished = data["isPublished"];
            this.publishDate = data["publishDate"] ? moment(data["publishDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.contact = data["contact"];
            this.contactTel = data["contactTel"];
            this.address = data["address"];
            this.note = data["note"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.customer = data["customer"] ? SimpleCustomerDto.fromJS(data["customer"]) : <any>undefined;
            if (Array.isArray(data["quotationOrderItems"])) {
                this.quotationOrderItems = [] as any;
                for (let item of data["quotationOrderItems"])
                    this.quotationOrderItems!.push(QuotationOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuotationOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["contact"] = this.contact;
        data["contactTel"] = this.contactTel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.quotationOrderItems)) {
            data["quotationOrderItems"] = [];
            for (let item of this.quotationOrderItems)
                data["quotationOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IQuotationOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    orderDate: moment.Moment;
    isPublished: boolean;
    publishDate: moment.Moment;
    customerId: string;
    contact: string | undefined;
    contactTel: string | undefined;
    address: string | undefined;
    note: string | undefined;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    customer: SimpleCustomerDto | undefined;
    quotationOrderItems: QuotationOrderItemDto[] | undefined;
}

export class QuotationOrderItemDto extends EntityDtoOfGuid implements IQuotationOrderItemDto {
    quotationOrderId!: string;
    quotationOrderNumber!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    unitId!: string;
    unitName!: string | undefined;
    moreThanQuantity!: number;
    price!: number;
    taxRate!: number;
    priceWithTax!: number;
    note!: string | undefined;

    constructor(data?: IQuotationOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.quotationOrderId = data["quotationOrderId"];
            this.quotationOrderNumber = data["quotationOrderNumber"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.moreThanQuantity = data["moreThanQuantity"];
            this.price = data["price"];
            this.taxRate = data["taxRate"];
            this.priceWithTax = data["priceWithTax"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): QuotationOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotationOrderId"] = this.quotationOrderId;
        data["quotationOrderNumber"] = this.quotationOrderNumber;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["moreThanQuantity"] = this.moreThanQuantity;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["priceWithTax"] = this.priceWithTax;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface IQuotationOrderItemDto extends IEntityDtoOfGuid {
    quotationOrderId: string;
    quotationOrderNumber: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    unitId: string;
    unitName: string | undefined;
    moreThanQuantity: number;
    price: number;
    taxRate: number;
    priceWithTax: number;
    note: string | undefined;
}

export class ListResultDtoOfQuotationOrderDto implements IListResultDtoOfQuotationOrderDto {
    items!: QuotationOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfQuotationOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfQuotationOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfQuotationOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfQuotationOrderDto {
    items: QuotationOrderDto[] | undefined;
}

export class PagedResultDtoOfQuotationOrderDto extends ListResultDtoOfQuotationOrderDto implements IPagedResultDtoOfQuotationOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfQuotationOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationOrderDto extends IListResultDtoOfQuotationOrderDto {
    totalCount: number;
}

export class PurchaseRequestOrderDto extends EntityDtoOfGuid implements IPurchaseRequestOrderDto {
    number!: string | undefined;
    buyerId!: string;
    buyerName!: string | undefined;
    orderDate!: moment.Moment;
    note!: string | undefined;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    purchaseRequestOrderItems!: PurchaseRequestOrderItemDto[] | undefined;

    constructor(data?: IPurchaseRequestOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.buyerId = data["buyerId"];
            this.buyerName = data["buyerName"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.note = data["note"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            if (Array.isArray(data["purchaseRequestOrderItems"])) {
                this.purchaseRequestOrderItems = [] as any;
                for (let item of data["purchaseRequestOrderItems"])
                    this.purchaseRequestOrderItems!.push(PurchaseRequestOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseRequestOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseRequestOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["buyerId"] = this.buyerId;
        data["buyerName"] = this.buyerName;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        if (Array.isArray(this.purchaseRequestOrderItems)) {
            data["purchaseRequestOrderItems"] = [];
            for (let item of this.purchaseRequestOrderItems)
                data["purchaseRequestOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseRequestOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    buyerId: string;
    buyerName: string | undefined;
    orderDate: moment.Moment;
    note: string | undefined;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    purchaseRequestOrderItems: PurchaseRequestOrderItemDto[] | undefined;
}

export class PurchaseRequestOrderItemDto extends EntityDtoOfGuid implements IPurchaseRequestOrderItemDto {
    purchaseRequestOrderId!: string;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitId!: string;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    quantity!: number;
    note!: string | undefined;

    constructor(data?: IPurchaseRequestOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.purchaseRequestOrderId = data["purchaseRequestOrderId"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitId = data["productBaseUnitId"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.quantity = data["quantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): PurchaseRequestOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseRequestOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseRequestOrderId"] = this.purchaseRequestOrderId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitId"] = this.productBaseUnitId;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["quantity"] = this.quantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseRequestOrderItemDto extends IEntityDtoOfGuid {
    purchaseRequestOrderId: string;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitId: string;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    quantity: number;
    note: string | undefined;
}

export class ListResultDtoOfPurchaseRequestOrderDto implements IListResultDtoOfPurchaseRequestOrderDto {
    items!: PurchaseRequestOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfPurchaseRequestOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PurchaseRequestOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPurchaseRequestOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPurchaseRequestOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPurchaseRequestOrderDto {
    items: PurchaseRequestOrderDto[] | undefined;
}

export class PagedResultDtoOfPurchaseRequestOrderDto extends ListResultDtoOfPurchaseRequestOrderDto implements IPagedResultDtoOfPurchaseRequestOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfPurchaseRequestOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfPurchaseRequestOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPurchaseRequestOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfPurchaseRequestOrderDto extends IListResultDtoOfPurchaseRequestOrderDto {
    totalCount: number;
}

export class PurchaseOutOrderDto extends EntityDtoOfGuid implements IPurchaseOutOrderDto {
    number!: string | undefined;
    orderDate!: moment.Moment;
    supplierId!: string;
    warehouseId!: string;
    contact!: string | undefined;
    contactTel!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    supplier!: SimpleSupplierDto | undefined;
    warehouse!: WarehouseDto | undefined;
    purchaseOutOrderItems!: PurchaseOutOrderItemDto[] | undefined;

    constructor(data?: IPurchaseOutOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.supplierId = data["supplierId"];
            this.warehouseId = data["warehouseId"];
            this.contact = data["contact"];
            this.contactTel = data["contactTel"];
            this.address = data["address"];
            this.note = data["note"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.supplier = data["supplier"] ? SimpleSupplierDto.fromJS(data["supplier"]) : <any>undefined;
            this.warehouse = data["warehouse"] ? WarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
            if (Array.isArray(data["purchaseOutOrderItems"])) {
                this.purchaseOutOrderItems = [] as any;
                for (let item of data["purchaseOutOrderItems"])
                    this.purchaseOutOrderItems!.push(PurchaseOutOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["supplierId"] = this.supplierId;
        data["warehouseId"] = this.warehouseId;
        data["contact"] = this.contact;
        data["contactTel"] = this.contactTel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        if (Array.isArray(this.purchaseOutOrderItems)) {
            data["purchaseOutOrderItems"] = [];
            for (let item of this.purchaseOutOrderItems)
                data["purchaseOutOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseOutOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    orderDate: moment.Moment;
    supplierId: string;
    warehouseId: string;
    contact: string | undefined;
    contactTel: string | undefined;
    address: string | undefined;
    note: string | undefined;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    supplier: SimpleSupplierDto | undefined;
    warehouse: WarehouseDto | undefined;
    purchaseOutOrderItems: PurchaseOutOrderItemDto[] | undefined;
}

export class ListResultDtoOfPurchaseOutOrderDto implements IListResultDtoOfPurchaseOutOrderDto {
    items!: PurchaseOutOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfPurchaseOutOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PurchaseOutOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPurchaseOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPurchaseOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPurchaseOutOrderDto {
    items: PurchaseOutOrderDto[] | undefined;
}

export class PagedResultDtoOfPurchaseOutOrderDto extends ListResultDtoOfPurchaseOutOrderDto implements IPagedResultDtoOfPurchaseOutOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfPurchaseOutOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfPurchaseOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPurchaseOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfPurchaseOutOrderDto extends IListResultDtoOfPurchaseOutOrderDto {
    totalCount: number;
}

export class PurchaseOrderDto extends EntityDtoOfGuid implements IPurchaseOrderDto {
    number!: string | undefined;
    supplierId!: string;
    supplier!: SimpleSupplierDto | undefined;
    contact!: string | undefined;
    contactTel!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    orderDate!: moment.Moment;
    deliveryDate!: moment.Moment;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    purchaseOrderItems!: PurchaseOrderItemDto[] | undefined;
    purchaseInOrderItems!: PurchaseInOrderItemDto[] | undefined;

    constructor(data?: IPurchaseOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.supplierId = data["supplierId"];
            this.supplier = data["supplier"] ? SimpleSupplierDto.fromJS(data["supplier"]) : <any>undefined;
            this.contact = data["contact"];
            this.contactTel = data["contactTel"];
            this.address = data["address"];
            this.note = data["note"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.deliveryDate = data["deliveryDate"] ? moment(data["deliveryDate"].toString()) : <any>undefined;
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            if (Array.isArray(data["purchaseOrderItems"])) {
                this.purchaseOrderItems = [] as any;
                for (let item of data["purchaseOrderItems"])
                    this.purchaseOrderItems!.push(PurchaseOrderItemDto.fromJS(item));
            }
            if (Array.isArray(data["purchaseInOrderItems"])) {
                this.purchaseInOrderItems = [] as any;
                for (let item of data["purchaseInOrderItems"])
                    this.purchaseInOrderItems!.push(PurchaseInOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["contact"] = this.contact;
        data["contactTel"] = this.contactTel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        if (Array.isArray(this.purchaseOrderItems)) {
            data["purchaseOrderItems"] = [];
            for (let item of this.purchaseOrderItems)
                data["purchaseOrderItems"].push(item.toJSON());
        }
        if (Array.isArray(this.purchaseInOrderItems)) {
            data["purchaseInOrderItems"] = [];
            for (let item of this.purchaseInOrderItems)
                data["purchaseInOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    supplierId: string;
    supplier: SimpleSupplierDto | undefined;
    contact: string | undefined;
    contactTel: string | undefined;
    address: string | undefined;
    note: string | undefined;
    orderDate: moment.Moment;
    deliveryDate: moment.Moment;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    purchaseOrderItems: PurchaseOrderItemDto[] | undefined;
    purchaseInOrderItems: PurchaseInOrderItemDto[] | undefined;
}

export class ListResultDtoOfPurchaseOrderDto implements IListResultDtoOfPurchaseOrderDto {
    items!: PurchaseOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfPurchaseOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PurchaseOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPurchaseOrderDto {
    items: PurchaseOrderDto[] | undefined;
}

export class PagedResultDtoOfPurchaseOrderDto extends ListResultDtoOfPurchaseOrderDto implements IPagedResultDtoOfPurchaseOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfPurchaseOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfPurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfPurchaseOrderDto extends IListResultDtoOfPurchaseOrderDto {
    totalCount: number;
}

export class PurchaseInOrderDto extends EntityDtoOfGuid implements IPurchaseInOrderDto {
    number!: string | undefined;
    supplierNumber!: string | undefined;
    orderDate!: moment.Moment;
    supplierId!: string;
    warehouseId!: string;
    contact!: string | undefined;
    contactTel!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    tenantId!: string | undefined;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    supplier!: SimpleSupplierDto | undefined;
    warehouse!: WarehouseDto | undefined;
    purchaseInOrderItems!: PurchaseInOrderItemDto[] | undefined;

    constructor(data?: IPurchaseInOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.supplierNumber = data["supplierNumber"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.supplierId = data["supplierId"];
            this.warehouseId = data["warehouseId"];
            this.contact = data["contact"];
            this.contactTel = data["contactTel"];
            this.address = data["address"];
            this.note = data["note"];
            this.tenantId = data["tenantId"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.supplier = data["supplier"] ? SimpleSupplierDto.fromJS(data["supplier"]) : <any>undefined;
            this.warehouse = data["warehouse"] ? WarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
            if (Array.isArray(data["purchaseInOrderItems"])) {
                this.purchaseInOrderItems = [] as any;
                for (let item of data["purchaseInOrderItems"])
                    this.purchaseInOrderItems!.push(PurchaseInOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["supplierNumber"] = this.supplierNumber;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["supplierId"] = this.supplierId;
        data["warehouseId"] = this.warehouseId;
        data["contact"] = this.contact;
        data["contactTel"] = this.contactTel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["tenantId"] = this.tenantId;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        if (Array.isArray(this.purchaseInOrderItems)) {
            data["purchaseInOrderItems"] = [];
            for (let item of this.purchaseInOrderItems)
                data["purchaseInOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPurchaseInOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    supplierNumber: string | undefined;
    orderDate: moment.Moment;
    supplierId: string;
    warehouseId: string;
    contact: string | undefined;
    contactTel: string | undefined;
    address: string | undefined;
    note: string | undefined;
    tenantId: string | undefined;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    supplier: SimpleSupplierDto | undefined;
    warehouse: WarehouseDto | undefined;
    purchaseInOrderItems: PurchaseInOrderItemDto[] | undefined;
}

export class ListResultDtoOfPurchaseInOrderDto implements IListResultDtoOfPurchaseInOrderDto {
    items!: PurchaseInOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfPurchaseInOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PurchaseInOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPurchaseInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPurchaseInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPurchaseInOrderDto {
    items: PurchaseInOrderDto[] | undefined;
}

export class PagedResultDtoOfPurchaseInOrderDto extends ListResultDtoOfPurchaseInOrderDto implements IPagedResultDtoOfPurchaseInOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfPurchaseInOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfPurchaseInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPurchaseInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfPurchaseInOrderDto extends IListResultDtoOfPurchaseInOrderDto {
    totalCount: number;
}

export class ListResultDtoOfProductDto implements IListResultDtoOfProductDto {
    items!: ProductDto[] | undefined;

    constructor(data?: IListResultDtoOfProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfProductDto {
    items: ProductDto[] | undefined;
}

export class PagedResultDtoOfProductDto extends ListResultDtoOfProductDto implements IPagedResultDtoOfProductDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfProductDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfProductDto extends IListResultDtoOfProductDto {
    totalCount: number;
}

export class ProductWithInventory implements IProductWithInventory {
    id!: string;
    name!: string | undefined;
    code!: string | undefined;
    spec!: string | undefined;
    costPrice!: number;
    salePrice!: number;
    taxRate!: number;
    note!: string | undefined;
    warehouseId!: string | undefined;
    warehouseName!: string | undefined;
    unitGroupName!: string | undefined;
    baseUnitId!: string;
    baseUnitName!: string | undefined;
    baseUnitRate!: number;
    purchaseUnitId!: string | undefined;
    purchaseUnitName!: string | undefined;
    purchaseUnitRate!: number | undefined;
    saleUnitId!: string | undefined;
    saleUnitName!: string | undefined;
    saleUnitRate!: number | undefined;
    storeUnitId!: string | undefined;
    storeUnitName!: string | undefined;
    storeUnitRate!: number | undefined;
    isActive!: boolean;
    inventoryQuantity!: number | undefined;

    constructor(data?: IProductWithInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.code = data["code"];
            this.spec = data["spec"];
            this.costPrice = data["costPrice"];
            this.salePrice = data["salePrice"];
            this.taxRate = data["taxRate"];
            this.note = data["note"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.unitGroupName = data["unitGroupName"];
            this.baseUnitId = data["baseUnitId"];
            this.baseUnitName = data["baseUnitName"];
            this.baseUnitRate = data["baseUnitRate"];
            this.purchaseUnitId = data["purchaseUnitId"];
            this.purchaseUnitName = data["purchaseUnitName"];
            this.purchaseUnitRate = data["purchaseUnitRate"];
            this.saleUnitId = data["saleUnitId"];
            this.saleUnitName = data["saleUnitName"];
            this.saleUnitRate = data["saleUnitRate"];
            this.storeUnitId = data["storeUnitId"];
            this.storeUnitName = data["storeUnitName"];
            this.storeUnitRate = data["storeUnitRate"];
            this.isActive = data["isActive"];
            this.inventoryQuantity = data["inventoryQuantity"];
        }
    }

    static fromJS(data: any): ProductWithInventory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithInventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["spec"] = this.spec;
        data["costPrice"] = this.costPrice;
        data["salePrice"] = this.salePrice;
        data["taxRate"] = this.taxRate;
        data["note"] = this.note;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["unitGroupName"] = this.unitGroupName;
        data["baseUnitId"] = this.baseUnitId;
        data["baseUnitName"] = this.baseUnitName;
        data["baseUnitRate"] = this.baseUnitRate;
        data["purchaseUnitId"] = this.purchaseUnitId;
        data["purchaseUnitName"] = this.purchaseUnitName;
        data["purchaseUnitRate"] = this.purchaseUnitRate;
        data["saleUnitId"] = this.saleUnitId;
        data["saleUnitName"] = this.saleUnitName;
        data["saleUnitRate"] = this.saleUnitRate;
        data["storeUnitId"] = this.storeUnitId;
        data["storeUnitName"] = this.storeUnitName;
        data["storeUnitRate"] = this.storeUnitRate;
        data["isActive"] = this.isActive;
        data["inventoryQuantity"] = this.inventoryQuantity;
        return data; 
    }
}

export interface IProductWithInventory {
    id: string;
    name: string | undefined;
    code: string | undefined;
    spec: string | undefined;
    costPrice: number;
    salePrice: number;
    taxRate: number;
    note: string | undefined;
    warehouseId: string | undefined;
    warehouseName: string | undefined;
    unitGroupName: string | undefined;
    baseUnitId: string;
    baseUnitName: string | undefined;
    baseUnitRate: number;
    purchaseUnitId: string | undefined;
    purchaseUnitName: string | undefined;
    purchaseUnitRate: number | undefined;
    saleUnitId: string | undefined;
    saleUnitName: string | undefined;
    saleUnitRate: number | undefined;
    storeUnitId: string | undefined;
    storeUnitName: string | undefined;
    storeUnitRate: number | undefined;
    isActive: boolean;
    inventoryQuantity: number | undefined;
}

export class ProductCategoryDto extends EntityDtoOfGuid implements IProductCategoryDto {
    name!: string | undefined;
    code!: string | undefined;
    level!: number;
    parentId!: string | undefined;
    parentName!: string | undefined;

    constructor(data?: IProductCategoryDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.level = data["level"];
            this.parentId = data["parentId"];
            this.parentName = data["parentName"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["level"] = this.level;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        super.toJSON(data);
        return data; 
    }
}

export interface IProductCategoryDto extends IEntityDtoOfGuid {
    name: string | undefined;
    code: string | undefined;
    level: number;
    parentId: string | undefined;
    parentName: string | undefined;
}

export class ListResultDtoOfProductCategoryDto implements IListResultDtoOfProductCategoryDto {
    items!: ProductCategoryDto[] | undefined;

    constructor(data?: IListResultDtoOfProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProductCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfProductCategoryDto {
    items: ProductCategoryDto[] | undefined;
}

export class PagedResultDtoOfProductCategoryDto extends ListResultDtoOfProductCategoryDto implements IPagedResultDtoOfProductCategoryDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfProductCategoryDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfProductCategoryDto extends IListResultDtoOfProductCategoryDto {
    totalCount: number;
}

export class PriceAjustmentOrderDto extends EntityDtoOfGuid implements IPriceAjustmentOrderDto {
    number!: string | undefined;
    orderDate!: moment.Moment;
    supplierId!: string;
    supplier!: SimpleSupplierDto | undefined;
    isPublished!: boolean;
    publishDate!: moment.Moment;
    note!: string | undefined;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    priceAjustmentOrderItems!: PriceAjustmentOrderItemDto[] | undefined;

    constructor(data?: IPriceAjustmentOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.supplierId = data["supplierId"];
            this.supplier = data["supplier"] ? SimpleSupplierDto.fromJS(data["supplier"]) : <any>undefined;
            this.isPublished = data["isPublished"];
            this.publishDate = data["publishDate"] ? moment(data["publishDate"].toString()) : <any>undefined;
            this.note = data["note"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            if (Array.isArray(data["priceAjustmentOrderItems"])) {
                this.priceAjustmentOrderItems = [] as any;
                for (let item of data["priceAjustmentOrderItems"])
                    this.priceAjustmentOrderItems!.push(PriceAjustmentOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PriceAjustmentOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceAjustmentOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        if (Array.isArray(this.priceAjustmentOrderItems)) {
            data["priceAjustmentOrderItems"] = [];
            for (let item of this.priceAjustmentOrderItems)
                data["priceAjustmentOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPriceAjustmentOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    orderDate: moment.Moment;
    supplierId: string;
    supplier: SimpleSupplierDto | undefined;
    isPublished: boolean;
    publishDate: moment.Moment;
    note: string | undefined;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    priceAjustmentOrderItems: PriceAjustmentOrderItemDto[] | undefined;
}

export class PriceAjustmentOrderItemDto extends EntityDtoOfGuid implements IPriceAjustmentOrderItemDto {
    priceAjustmentOrderId!: string;
    priceAjustmentOrderNumber!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitId!: string;
    unitName!: string | undefined;
    unitRate!: number;
    moreThanQuantity!: number;
    price!: number;
    taxRate!: number;
    priceWithTax!: number;

    constructor(data?: IPriceAjustmentOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.priceAjustmentOrderId = data["priceAjustmentOrderId"];
            this.priceAjustmentOrderNumber = data["priceAjustmentOrderNumber"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.unitRate = data["unitRate"];
            this.moreThanQuantity = data["moreThanQuantity"];
            this.price = data["price"];
            this.taxRate = data["taxRate"];
            this.priceWithTax = data["priceWithTax"];
        }
    }

    static fromJS(data: any): PriceAjustmentOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceAjustmentOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceAjustmentOrderId"] = this.priceAjustmentOrderId;
        data["priceAjustmentOrderNumber"] = this.priceAjustmentOrderNumber;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["unitRate"] = this.unitRate;
        data["moreThanQuantity"] = this.moreThanQuantity;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["priceWithTax"] = this.priceWithTax;
        super.toJSON(data);
        return data; 
    }
}

export interface IPriceAjustmentOrderItemDto extends IEntityDtoOfGuid {
    priceAjustmentOrderId: string;
    priceAjustmentOrderNumber: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitId: string;
    unitName: string | undefined;
    unitRate: number;
    moreThanQuantity: number;
    price: number;
    taxRate: number;
    priceWithTax: number;
}

export class ListResultDtoOfPriceAjustmentOrderDto implements IListResultDtoOfPriceAjustmentOrderDto {
    items!: PriceAjustmentOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfPriceAjustmentOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PriceAjustmentOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPriceAjustmentOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPriceAjustmentOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPriceAjustmentOrderDto {
    items: PriceAjustmentOrderDto[] | undefined;
}

export class PagedResultDtoOfPriceAjustmentOrderDto extends ListResultDtoOfPriceAjustmentOrderDto implements IPagedResultDtoOfPriceAjustmentOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfPriceAjustmentOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfPriceAjustmentOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPriceAjustmentOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfPriceAjustmentOrderDto extends IListResultDtoOfPriceAjustmentOrderDto {
    totalCount: number;
}

export class OtherOutOrderDto extends EntityDtoOfGuid implements IOtherOutOrderDto {
    number!: string | undefined;
    orderDate!: moment.Moment;
    handlerId!: string;
    warehouseId!: string;
    note!: string | undefined;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    warehouse!: WarehouseDto | undefined;
    handler!: PSIUserData | undefined;
    otherOutOrderItems!: OtherOutOrderItemDto[] | undefined;

    constructor(data?: IOtherOutOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.handlerId = data["handlerId"];
            this.warehouseId = data["warehouseId"];
            this.note = data["note"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.warehouse = data["warehouse"] ? WarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
            this.handler = data["handler"] ? PSIUserData.fromJS(data["handler"]) : <any>undefined;
            if (Array.isArray(data["otherOutOrderItems"])) {
                this.otherOutOrderItems = [] as any;
                for (let item of data["otherOutOrderItems"])
                    this.otherOutOrderItems!.push(OtherOutOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OtherOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["handlerId"] = this.handlerId;
        data["warehouseId"] = this.warehouseId;
        data["note"] = this.note;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        data["handler"] = this.handler ? this.handler.toJSON() : <any>undefined;
        if (Array.isArray(this.otherOutOrderItems)) {
            data["otherOutOrderItems"] = [];
            for (let item of this.otherOutOrderItems)
                data["otherOutOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOtherOutOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    orderDate: moment.Moment;
    handlerId: string;
    warehouseId: string;
    note: string | undefined;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    warehouse: WarehouseDto | undefined;
    handler: PSIUserData | undefined;
    otherOutOrderItems: OtherOutOrderItemDto[] | undefined;
}

export class PSIUserData implements IPSIUserData {
    id!: string;
    tenantId!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string | undefined;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;

    constructor(data?: IPSIUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.emailConfirmed = data["emailConfirmed"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneNumberConfirmed = data["phoneNumberConfirmed"];
        }
    }

    static fromJS(data: any): PSIUserData {
        data = typeof data === 'object' ? data : {};
        let result = new PSIUserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        return data; 
    }
}

export interface IPSIUserData {
    id: string;
    tenantId: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    email: string | undefined;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
}

export class OtherOutOrderItemDto extends EntityDtoOfGuid implements IOtherOutOrderItemDto {
    otherOutOrderId!: string;
    warehouseId!: string;
    warehouseName!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitRate!: number;
    unitId!: string;
    unitName!: string | undefined;
    quantity!: number;
    note!: string | undefined;

    constructor(data?: IOtherOutOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.otherOutOrderId = data["otherOutOrderId"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitRate = data["unitRate"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.quantity = data["quantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): OtherOutOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherOutOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["otherOutOrderId"] = this.otherOutOrderId;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitRate"] = this.unitRate;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["quantity"] = this.quantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface IOtherOutOrderItemDto extends IEntityDtoOfGuid {
    otherOutOrderId: string;
    warehouseId: string;
    warehouseName: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitRate: number;
    unitId: string;
    unitName: string | undefined;
    quantity: number;
    note: string | undefined;
}

export class ListResultDtoOfOtherOutOrderDto implements IListResultDtoOfOtherOutOrderDto {
    items!: OtherOutOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfOtherOutOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OtherOutOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOtherOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOtherOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOtherOutOrderDto {
    items: OtherOutOrderDto[] | undefined;
}

export class PagedResultDtoOfOtherOutOrderDto extends ListResultDtoOfOtherOutOrderDto implements IPagedResultDtoOfOtherOutOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfOtherOutOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfOtherOutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOtherOutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfOtherOutOrderDto extends IListResultDtoOfOtherOutOrderDto {
    totalCount: number;
}

export class OtherInOrderDto extends EntityDtoOfGuid implements IOtherInOrderDto {
    number!: string | undefined;
    orderDate!: moment.Moment;
    handlerId!: string;
    warehouseId!: string;
    note!: string | undefined;
    orderState!: number;
    auditorId!: string | undefined;
    auditor!: string | undefined;
    auditDate!: moment.Moment | undefined;
    makerId!: string;
    maker!: string | undefined;
    makeDate!: moment.Moment;
    warehouse!: WarehouseDto | undefined;
    handler!: PSIUserData | undefined;
    otherInOrderItems!: OtherInOrderItemDto[] | undefined;

    constructor(data?: IOtherInOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.number = data["number"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.handlerId = data["handlerId"];
            this.warehouseId = data["warehouseId"];
            this.note = data["note"];
            this.orderState = data["orderState"];
            this.auditorId = data["auditorId"];
            this.auditor = data["auditor"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.makerId = data["makerId"];
            this.maker = data["maker"];
            this.makeDate = data["makeDate"] ? moment(data["makeDate"].toString()) : <any>undefined;
            this.warehouse = data["warehouse"] ? WarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
            this.handler = data["handler"] ? PSIUserData.fromJS(data["handler"]) : <any>undefined;
            if (Array.isArray(data["otherInOrderItems"])) {
                this.otherInOrderItems = [] as any;
                for (let item of data["otherInOrderItems"])
                    this.otherInOrderItems!.push(OtherInOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OtherInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["handlerId"] = this.handlerId;
        data["warehouseId"] = this.warehouseId;
        data["note"] = this.note;
        data["orderState"] = this.orderState;
        data["auditorId"] = this.auditorId;
        data["auditor"] = this.auditor;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["makerId"] = this.makerId;
        data["maker"] = this.maker;
        data["makeDate"] = this.makeDate ? this.makeDate.toISOString() : <any>undefined;
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        data["handler"] = this.handler ? this.handler.toJSON() : <any>undefined;
        if (Array.isArray(this.otherInOrderItems)) {
            data["otherInOrderItems"] = [];
            for (let item of this.otherInOrderItems)
                data["otherInOrderItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOtherInOrderDto extends IEntityDtoOfGuid {
    number: string | undefined;
    orderDate: moment.Moment;
    handlerId: string;
    warehouseId: string;
    note: string | undefined;
    orderState: number;
    auditorId: string | undefined;
    auditor: string | undefined;
    auditDate: moment.Moment | undefined;
    makerId: string;
    maker: string | undefined;
    makeDate: moment.Moment;
    warehouse: WarehouseDto | undefined;
    handler: PSIUserData | undefined;
    otherInOrderItems: OtherInOrderItemDto[] | undefined;
}

export class OtherInOrderItemDto extends EntityDtoOfGuid implements IOtherInOrderItemDto {
    otherInOrderId!: string;
    warehouseId!: string;
    warehouseName!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productSpec!: string | undefined;
    productBaseUnitName!: string | undefined;
    productBaseUnitQuantity!: number;
    unitRate!: number;
    unitId!: string;
    unitName!: string | undefined;
    quantity!: number;
    note!: string | undefined;

    constructor(data?: IOtherInOrderItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.otherInOrderId = data["otherInOrderId"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productSpec = data["productSpec"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitQuantity = data["productBaseUnitQuantity"];
            this.unitRate = data["unitRate"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.quantity = data["quantity"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): OtherInOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherInOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["otherInOrderId"] = this.otherInOrderId;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productSpec"] = this.productSpec;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitQuantity"] = this.productBaseUnitQuantity;
        data["unitRate"] = this.unitRate;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["quantity"] = this.quantity;
        data["note"] = this.note;
        super.toJSON(data);
        return data; 
    }
}

export interface IOtherInOrderItemDto extends IEntityDtoOfGuid {
    otherInOrderId: string;
    warehouseId: string;
    warehouseName: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productSpec: string | undefined;
    productBaseUnitName: string | undefined;
    productBaseUnitQuantity: number;
    unitRate: number;
    unitId: string;
    unitName: string | undefined;
    quantity: number;
    note: string | undefined;
}

export class ListResultDtoOfOtherInOrderDto implements IListResultDtoOfOtherInOrderDto {
    items!: OtherInOrderDto[] | undefined;

    constructor(data?: IListResultDtoOfOtherInOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OtherInOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOtherInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOtherInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOtherInOrderDto {
    items: OtherInOrderDto[] | undefined;
}

export class PagedResultDtoOfOtherInOrderDto extends ListResultDtoOfOtherInOrderDto implements IPagedResultDtoOfOtherInOrderDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfOtherInOrderDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfOtherInOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOtherInOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfOtherInOrderDto extends IListResultDtoOfOtherInOrderDto {
    totalCount: number;
}

export class ListResultDtoOfInventoryDto implements IListResultDtoOfInventoryDto {
    items!: InventoryDto[] | undefined;

    constructor(data?: IListResultDtoOfInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(InventoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfInventoryDto {
    items: InventoryDto[] | undefined;
}

export class PagedResultDtoOfInventoryDto extends ListResultDtoOfInventoryDto implements IPagedResultDtoOfInventoryDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfInventoryDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfInventoryDto extends IListResultDtoOfInventoryDto {
    totalCount: number;
}

export class InventoryDto extends EntityDtoOfGuid implements IInventoryDto {
    warehouseId!: string;
    warehouseName!: string | undefined;
    productId!: string;
    productCode!: string | undefined;
    productName!: string | undefined;
    productBaseUnitName!: string | undefined;
    productBaseUnitRate!: number;
    quantity!: number;

    constructor(data?: IInventoryDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productBaseUnitName = data["productBaseUnitName"];
            this.productBaseUnitRate = data["productBaseUnitRate"];
            this.quantity = data["quantity"];
        }
    }

    static fromJS(data: any): InventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productBaseUnitName"] = this.productBaseUnitName;
        data["productBaseUnitRate"] = this.productBaseUnitRate;
        data["quantity"] = this.quantity;
        super.toJSON(data);
        return data; 
    }
}

export interface IInventoryDto extends IEntityDtoOfGuid {
    warehouseId: string;
    warehouseName: string | undefined;
    productId: string;
    productCode: string | undefined;
    productName: string | undefined;
    productBaseUnitName: string | undefined;
    productBaseUnitRate: number;
    quantity: number;
}

export class CustomerDto extends EntityDtoOfGuid implements ICustomerDto {
    code!: string | undefined;
    name!: string | undefined;
    defaultContact!: ContactPerson | undefined;
    address!: string | undefined;
    isActive!: boolean;
    customerContacts!: CustomerContactDto[] | undefined;
    attachments!: AttachmentInfo[] | undefined;

    constructor(data?: ICustomerDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.defaultContact = data["defaultContact"] ? ContactPerson.fromJS(data["defaultContact"]) : <any>undefined;
            this.address = data["address"];
            this.isActive = data["isActive"];
            if (Array.isArray(data["customerContacts"])) {
                this.customerContacts = [] as any;
                for (let item of data["customerContacts"])
                    this.customerContacts!.push(CustomerContactDto.fromJS(item));
            }
            if (Array.isArray(data["attachments"])) {
                this.attachments = [] as any;
                for (let item of data["attachments"])
                    this.attachments!.push(AttachmentInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["defaultContact"] = this.defaultContact ? this.defaultContact.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.customerContacts)) {
            data["customerContacts"] = [];
            for (let item of this.customerContacts)
                data["customerContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerDto extends IEntityDtoOfGuid {
    code: string | undefined;
    name: string | undefined;
    defaultContact: ContactPerson | undefined;
    address: string | undefined;
    isActive: boolean;
    customerContacts: CustomerContactDto[] | undefined;
    attachments: AttachmentInfo[] | undefined;
}

export class CustomerContactDto extends EntityDtoOfGuid implements ICustomerContactDto {
    customerId!: string;
    customerName!: string | undefined;
    contact!: ContactPerson | undefined;
    note!: string | undefined;
    isDefault!: boolean;

    constructor(data?: ICustomerContactDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
            this.customerName = data["customerName"];
            this.contact = data["contact"] ? ContactPerson.fromJS(data["contact"]) : <any>undefined;
            this.note = data["note"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): CustomerContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["note"] = this.note;
        data["isDefault"] = this.isDefault;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerContactDto extends IEntityDtoOfGuid {
    customerId: string;
    customerName: string | undefined;
    contact: ContactPerson | undefined;
    note: string | undefined;
    isDefault: boolean;
}

export class ListResultDtoOfCustomerDto implements IListResultDtoOfCustomerDto {
    items!: CustomerDto[] | undefined;

    constructor(data?: IListResultDtoOfCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCustomerDto {
    items: CustomerDto[] | undefined;
}

export class PagedResultDtoOfCustomerDto extends ListResultDtoOfCustomerDto implements IPagedResultDtoOfCustomerDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfCustomerDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerDto extends IListResultDtoOfCustomerDto {
    totalCount: number;
}

export class ListResultDtoOfCustomerPriceDto implements IListResultDtoOfCustomerPriceDto {
    items!: CustomerPriceDto[] | undefined;

    constructor(data?: IListResultDtoOfCustomerPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerPriceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCustomerPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCustomerPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCustomerPriceDto {
    items: CustomerPriceDto[] | undefined;
}

export class PagedResultDtoOfCustomerPriceDto extends ListResultDtoOfCustomerPriceDto implements IPagedResultDtoOfCustomerPriceDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfCustomerPriceDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerPriceDto extends IListResultDtoOfCustomerPriceDto {
    totalCount: number;
}

export class CustomerPriceDto implements ICustomerPriceDto {
    customerId!: string;
    productId!: string;
    unitId!: string;
    unitRate!: number;
    moreThanQuantity!: number;
    price!: number;
    taxRate!: number;
    priceWithTax!: number;
    customer!: SimpleCustomerDto | undefined;
    product!: SimpleProductDto | undefined;
    unit!: UnitDto | undefined;

    constructor(data?: ICustomerPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerId = data["customerId"];
            this.productId = data["productId"];
            this.unitId = data["unitId"];
            this.unitRate = data["unitRate"];
            this.moreThanQuantity = data["moreThanQuantity"];
            this.price = data["price"];
            this.taxRate = data["taxRate"];
            this.priceWithTax = data["priceWithTax"];
            this.customer = data["customer"] ? SimpleCustomerDto.fromJS(data["customer"]) : <any>undefined;
            this.product = data["product"] ? SimpleProductDto.fromJS(data["product"]) : <any>undefined;
            this.unit = data["unit"] ? UnitDto.fromJS(data["unit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["productId"] = this.productId;
        data["unitId"] = this.unitId;
        data["unitRate"] = this.unitRate;
        data["moreThanQuantity"] = this.moreThanQuantity;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["priceWithTax"] = this.priceWithTax;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICustomerPriceDto {
    customerId: string;
    productId: string;
    unitId: string;
    unitRate: number;
    moreThanQuantity: number;
    price: number;
    taxRate: number;
    priceWithTax: number;
    customer: SimpleCustomerDto | undefined;
    product: SimpleProductDto | undefined;
    unit: UnitDto | undefined;
}

export class DictionaryItemDto implements IDictionaryItemDto {
    groupName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    value!: string | undefined;
    displayValue!: string | undefined;
    isDisable!: boolean;

    constructor(data?: IDictionaryItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupName = data["groupName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.value = data["value"];
            this.displayValue = data["displayValue"];
            this.isDisable = data["isDisable"];
        }
    }

    static fromJS(data: any): DictionaryItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionaryItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        data["displayValue"] = this.displayValue;
        data["isDisable"] = this.isDisable;
        return data; 
    }
}

export interface IDictionaryItemDto {
    groupName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    value: string | undefined;
    displayValue: string | undefined;
    isDisable: boolean;
}

export class DictionaryCategoryDto implements IDictionaryCategoryDto {
    groupName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    isDisable!: boolean;

    constructor(data?: IDictionaryCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupName = data["groupName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isDisable = data["isDisable"];
        }
    }

    static fromJS(data: any): DictionaryCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionaryCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDisable"] = this.isDisable;
        return data; 
    }
}

export interface IDictionaryCategoryDto {
    groupName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    isDisable: boolean;
}

export class ZeroEmailSettingDto implements IZeroEmailSettingDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    host!: string | undefined;
    port!: number;
    enableSsl!: boolean;
    useDefaultCredentials!: boolean;
    userName!: string | undefined;
    password!: string | undefined;
    domain!: string | undefined;

    constructor(data?: IZeroEmailSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.host = data["host"];
            this.port = data["port"];
            this.enableSsl = data["enableSsl"];
            this.useDefaultCredentials = data["useDefaultCredentials"];
            this.userName = data["userName"];
            this.password = data["password"];
            this.domain = data["domain"];
        }
    }

    static fromJS(data: any): ZeroEmailSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZeroEmailSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["host"] = this.host;
        data["port"] = this.port;
        data["enableSsl"] = this.enableSsl;
        data["useDefaultCredentials"] = this.useDefaultCredentials;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["domain"] = this.domain;
        return data; 
    }
}

export interface IZeroEmailSettingDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    host: string | undefined;
    port: number;
    enableSsl: boolean;
    useDefaultCredentials: boolean;
    userName: string | undefined;
    password: string | undefined;
    domain: string | undefined;
}

export class ZeroSecuritySettingDto implements IZeroSecuritySettingDto {
    password!: PasswordSettingDto | undefined;
    lockout!: LockoutSettingDto | undefined;
    signIn!: SignInSettingDto | undefined;
    user!: UserSettingDto | undefined;

    constructor(data?: IZeroSecuritySettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"] ? PasswordSettingDto.fromJS(data["password"]) : <any>undefined;
            this.lockout = data["lockout"] ? LockoutSettingDto.fromJS(data["lockout"]) : <any>undefined;
            this.signIn = data["signIn"] ? SignInSettingDto.fromJS(data["signIn"]) : <any>undefined;
            this.user = data["user"] ? UserSettingDto.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ZeroSecuritySettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZeroSecuritySettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password ? this.password.toJSON() : <any>undefined;
        data["lockout"] = this.lockout ? this.lockout.toJSON() : <any>undefined;
        data["signIn"] = this.signIn ? this.signIn.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IZeroSecuritySettingDto {
    password: PasswordSettingDto | undefined;
    lockout: LockoutSettingDto | undefined;
    signIn: SignInSettingDto | undefined;
    user: UserSettingDto | undefined;
}

export class PasswordSettingDto implements IPasswordSettingDto {
    requiredLength!: number;
    requiredUniqueChars!: number;
    requireNonAlphanumeric!: boolean;
    requireLowercase!: boolean;
    requireUppercase!: boolean;
    requireDigit!: boolean;

    constructor(data?: IPasswordSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requiredLength = data["requiredLength"];
            this.requiredUniqueChars = data["requiredUniqueChars"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireLowercase = data["requireLowercase"];
            this.requireUppercase = data["requireUppercase"];
            this.requireDigit = data["requireDigit"];
        }
    }

    static fromJS(data: any): PasswordSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredLength"] = this.requiredLength;
        data["requiredUniqueChars"] = this.requiredUniqueChars;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireLowercase"] = this.requireLowercase;
        data["requireUppercase"] = this.requireUppercase;
        data["requireDigit"] = this.requireDigit;
        return data; 
    }
}

export interface IPasswordSettingDto {
    requiredLength: number;
    requiredUniqueChars: number;
    requireNonAlphanumeric: boolean;
    requireLowercase: boolean;
    requireUppercase: boolean;
    requireDigit: boolean;
}

export class LockoutSettingDto implements ILockoutSettingDto {
    allowedForNewUsers!: boolean;
    lockoutDuration!: number;
    maxFailedAccessAttempts!: number;

    constructor(data?: ILockoutSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowedForNewUsers = data["allowedForNewUsers"];
            this.lockoutDuration = data["lockoutDuration"];
            this.maxFailedAccessAttempts = data["maxFailedAccessAttempts"];
        }
    }

    static fromJS(data: any): LockoutSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new LockoutSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowedForNewUsers"] = this.allowedForNewUsers;
        data["lockoutDuration"] = this.lockoutDuration;
        data["maxFailedAccessAttempts"] = this.maxFailedAccessAttempts;
        return data; 
    }
}

export interface ILockoutSettingDto {
    allowedForNewUsers: boolean;
    lockoutDuration: number;
    maxFailedAccessAttempts: number;
}

export class SignInSettingDto implements ISignInSettingDto {
    requireConfirmedEmail!: boolean;
    requireConfirmedPhoneNumber!: boolean;

    constructor(data?: ISignInSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireConfirmedEmail = data["requireConfirmedEmail"];
            this.requireConfirmedPhoneNumber = data["requireConfirmedPhoneNumber"];
        }
    }

    static fromJS(data: any): SignInSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignInSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireConfirmedEmail"] = this.requireConfirmedEmail;
        data["requireConfirmedPhoneNumber"] = this.requireConfirmedPhoneNumber;
        return data; 
    }
}

export interface ISignInSettingDto {
    requireConfirmedEmail: boolean;
    requireConfirmedPhoneNumber: boolean;
}

export class UserSettingDto implements IUserSettingDto {
    isUserNameUpdateEnabled!: boolean;
    isEmailUpdateEnabled!: boolean;

    constructor(data?: IUserSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isUserNameUpdateEnabled = data["isUserNameUpdateEnabled"];
            this.isEmailUpdateEnabled = data["isEmailUpdateEnabled"];
        }
    }

    static fromJS(data: any): UserSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserNameUpdateEnabled"] = this.isUserNameUpdateEnabled;
        data["isEmailUpdateEnabled"] = this.isEmailUpdateEnabled;
        return data; 
    }
}

export interface IUserSettingDto {
    isUserNameUpdateEnabled: boolean;
    isEmailUpdateEnabled: boolean;
}

export class ListResultDtoOfAuditLogListDto implements IListResultDtoOfAuditLogListDto {
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IListResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAuditLogListDto {
    items: AuditLogListDto[] | undefined;
}

export class PagedResultDtoOfAuditLogListDto extends ListResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto extends IListResultDtoOfAuditLogListDto {
    totalCount: number;
}

export class AuditLogListDto implements IAuditLogListDto {
    id!: string;
    httpStatusCode!: number | undefined;
    comments!: string | undefined;
    exceptions!: string | undefined;
    url!: string | undefined;
    httpMethod!: string | undefined;
    browserInfo!: string | undefined;
    clientName!: string | undefined;
    clientIpAddress!: string | undefined;
    executionDuration!: number;
    executionTime!: moment.Moment;
    impersonatorTenantId!: string | undefined;
    impersonatorUserId!: string | undefined;
    tenantId!: string | undefined;
    userName!: string | undefined;
    userId!: string | undefined;
    entityChanges!: EntityChangeDto[] | undefined;
    actions!: AuditLogActionDto[] | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.httpStatusCode = data["httpStatusCode"];
            this.comments = data["comments"];
            this.exceptions = data["exceptions"];
            this.url = data["url"];
            this.httpMethod = data["httpMethod"];
            this.browserInfo = data["browserInfo"];
            this.clientName = data["clientName"];
            this.clientIpAddress = data["clientIpAddress"];
            this.executionDuration = data["executionDuration"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.tenantId = data["tenantId"];
            this.userName = data["userName"];
            this.userId = data["userId"];
            if (Array.isArray(data["entityChanges"])) {
                this.entityChanges = [] as any;
                for (let item of data["entityChanges"])
                    this.entityChanges!.push(EntityChangeDto.fromJS(item));
            }
            if (Array.isArray(data["actions"])) {
                this.actions = [] as any;
                for (let item of data["actions"])
                    this.actions!.push(AuditLogActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["httpStatusCode"] = this.httpStatusCode;
        data["comments"] = this.comments;
        data["exceptions"] = this.exceptions;
        data["url"] = this.url;
        data["httpMethod"] = this.httpMethod;
        data["browserInfo"] = this.browserInfo;
        data["clientName"] = this.clientName;
        data["clientIpAddress"] = this.clientIpAddress;
        data["executionDuration"] = this.executionDuration;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        if (Array.isArray(this.entityChanges)) {
            data["entityChanges"] = [];
            for (let item of this.entityChanges)
                data["entityChanges"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuditLogListDto {
    id: string;
    httpStatusCode: number | undefined;
    comments: string | undefined;
    exceptions: string | undefined;
    url: string | undefined;
    httpMethod: string | undefined;
    browserInfo: string | undefined;
    clientName: string | undefined;
    clientIpAddress: string | undefined;
    executionDuration: number;
    executionTime: moment.Moment;
    impersonatorTenantId: string | undefined;
    impersonatorUserId: string | undefined;
    tenantId: string | undefined;
    userName: string | undefined;
    userId: string | undefined;
    entityChanges: EntityChangeDto[] | undefined;
    actions: AuditLogActionDto[] | undefined;
}

export class EntityChangeDto implements IEntityChangeDto {
    auditLogId!: string;
    tenantId!: string | undefined;
    changeTime!: moment.Moment;
    changeType!: EntityChangeType;
    entityId!: string | undefined;
    entityTypeFullName!: string | undefined;
    propertyChanges!: EntityPropertyChangeDto[] | undefined;

    constructor(data?: IEntityChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.auditLogId = data["auditLogId"];
            this.tenantId = data["tenantId"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.changeType = data["changeType"];
            this.entityId = data["entityId"];
            this.entityTypeFullName = data["entityTypeFullName"];
            if (Array.isArray(data["propertyChanges"])) {
                this.propertyChanges = [] as any;
                for (let item of data["propertyChanges"])
                    this.propertyChanges!.push(EntityPropertyChangeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditLogId"] = this.auditLogId;
        data["tenantId"] = this.tenantId;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["changeType"] = this.changeType;
        data["entityId"] = this.entityId;
        data["entityTypeFullName"] = this.entityTypeFullName;
        if (Array.isArray(this.propertyChanges)) {
            data["propertyChanges"] = [];
            for (let item of this.propertyChanges)
                data["propertyChanges"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEntityChangeDto {
    auditLogId: string;
    tenantId: string | undefined;
    changeTime: moment.Moment;
    changeType: EntityChangeType;
    entityId: string | undefined;
    entityTypeFullName: string | undefined;
    propertyChanges: EntityPropertyChangeDto[] | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    tenantId!: string | undefined;
    entityChangeId!: string;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    tenantId: string | undefined;
    entityChangeId: string;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
}

export class AuditLogActionDto implements IAuditLogActionDto {
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment;
    executionDuration!: number;

    constructor(data?: IAuditLogActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
        }
    }

    static fromJS(data: any): AuditLogActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        return data; 
    }
}

export interface IAuditLogActionDto {
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
}

export class AnubUserDto extends IdentityUserDto implements IAnubUserDto {
    parentId!: string | undefined;
    code!: string | undefined;
    parentName!: string | undefined;

    constructor(data?: IAnubUserDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.parentName = data["parentName"];
        }
    }

    static fromJS(data: any): AnubUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnubUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["parentName"] = this.parentName;
        super.toJSON(data);
        return data; 
    }
}

export interface IAnubUserDto extends IIdentityUserDto {
    parentId: string | undefined;
    code: string | undefined;
    parentName: string | undefined;
}

export class AnubUserCreateDto extends IdentityUserCreateDto implements IAnubUserCreateDto {
    parentId!: string | undefined;

    constructor(data?: IAnubUserCreateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.parentId = data["parentId"];
        }
    }

    static fromJS(data: any): AnubUserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnubUserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IAnubUserCreateDto extends IIdentityUserCreateDto {
    parentId: string | undefined;
}

export class ListResultDtoOfAnubUserDto implements IListResultDtoOfAnubUserDto {
    items!: AnubUserDto[] | undefined;

    constructor(data?: IListResultDtoOfAnubUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AnubUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAnubUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAnubUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAnubUserDto {
    items: AnubUserDto[] | undefined;
}

export class PagedResultDtoOfAnubUserDto extends ListResultDtoOfAnubUserDto implements IPagedResultDtoOfAnubUserDto {
    totalCount!: number;

    constructor(data?: IPagedResultDtoOfAnubUserDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfAnubUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAnubUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultDtoOfAnubUserDto extends IListResultDtoOfAnubUserDto {
    totalCount: number;
}

export class AnubUserUpdateDto extends IdentityUserUpdateDto implements IAnubUserUpdateDto {
    parentId!: string | undefined;

    constructor(data?: IAnubUserUpdateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.parentId = data["parentId"];
        }
    }

    static fromJS(data: any): AnubUserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnubUserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IAnubUserUpdateDto extends IIdentityUserUpdateDto {
    parentId: string | undefined;
}

export class CreateTemplateInput implements ICreateTemplateInput {
    name!: string | undefined;
    templateName!: string | undefined;
    templateDisplayName!: string | undefined;
    content!: string | undefined;

    constructor(data?: ICreateTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.templateName = data["templateName"];
            this.templateDisplayName = data["templateDisplayName"];
            this.content = data["content"];
        }
    }

    static fromJS(data: any): CreateTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["templateName"] = this.templateName;
        data["templateDisplayName"] = this.templateDisplayName;
        data["content"] = this.content;
        return data; 
    }
}

export interface ICreateTemplateInput {
    name: string | undefined;
    templateName: string | undefined;
    templateDisplayName: string | undefined;
    content: string | undefined;
}

export class ListResultDtoOfReportTemplateDto implements IListResultDtoOfReportTemplateDto {
    items!: ReportTemplateDto[] | undefined;

    constructor(data?: IListResultDtoOfReportTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ReportTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfReportTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfReportTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfReportTemplateDto {
    items: ReportTemplateDto[] | undefined;
}

export class ReportTemplateDto implements IReportTemplateDto {
    reportName!: string | undefined;
    displayName!: string | undefined;
    templateName!: string | undefined;
    templateDisplayName!: string | undefined;

    constructor(data?: IReportTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportName = data["reportName"];
            this.displayName = data["displayName"];
            this.templateName = data["templateName"];
            this.templateDisplayName = data["templateDisplayName"];
        }
    }

    static fromJS(data: any): ReportTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportName"] = this.reportName;
        data["displayName"] = this.displayName;
        data["templateName"] = this.templateName;
        data["templateDisplayName"] = this.templateDisplayName;
        return data; 
    }
}

export interface IReportTemplateDto {
    reportName: string | undefined;
    displayName: string | undefined;
    templateName: string | undefined;
    templateDisplayName: string | undefined;
}

export class UploadTemplateInput implements IUploadTemplateInput {
    name!: string | undefined;
    templateName!: string | undefined;
    templateDisplayName!: string | undefined;
    file!: FileDto | undefined;

    constructor(data?: IUploadTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.templateName = data["templateName"];
            this.templateDisplayName = data["templateDisplayName"];
            this.file = data["file"] ? FileDto.fromJS(data["file"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UploadTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["templateName"] = this.templateName;
        data["templateDisplayName"] = this.templateDisplayName;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUploadTemplateInput {
    name: string | undefined;
    templateName: string | undefined;
    templateDisplayName: string | undefined;
    file: FileDto | undefined;
}

export class ListResultDtoOfApplicationMenuItem implements IListResultDtoOfApplicationMenuItem {
    items!: ApplicationMenuItem[] | undefined;

    constructor(data?: IListResultDtoOfApplicationMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfApplicationMenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfApplicationMenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfApplicationMenuItem {
    items: ApplicationMenuItem[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}